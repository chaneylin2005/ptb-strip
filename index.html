<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth Strip Designer T√πy Ch·ªânh (Phi√™n b·∫£n ƒê·∫ßy ƒë·ªß - C√≥ Google Fonts)</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Montserrat:ital,wght@0,400;0,700;1,400&family=Pacifico&family=Pinyon+Script&display=swap" rel="stylesheet">
    
    <style>
        /* ==================== CSS CHUNG ==================== */
        body { font-family: 'Montserrat', sans-serif; margin: 0; padding: 0; background-color: #f4f4f9; color: #333; }
        header { background-color: #007bff; color: white; padding: 20px; text-align: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        button, .primary-action, .secondary-action { border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; width: 100%; margin-top: 5px; }
        .primary-action { background-color: #28a745; color: white; font-size: 1.1em; margin-top: 20px; }
        .primary-action:hover { background-color: #1e7e34; }
        .secondary-action { background-color: #6c757d; color: white; }
        .secondary-action:hover { background-color: #5a6268; }
        .alert-message { background-color: #fff3cd; color: #856404; padding: 10px; border: 1px solid #ffeeba; border-radius: 4px; margin-bottom: 20px; text-align: center; }

        /* ==================== CH·∫æ ƒê·ªò THI·∫æT K·∫æ (DESIGN MODE) ==================== */
        #design-view { display: flex; max-width: 1200px; margin: 20px auto; padding: 0 15px; }
        .design-area { flex: 2; padding-right: 30px; text-align: center; }
        #photoStripCanvas { border: 5px dashed #ccc; background-color: white; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); max-width: 100%; height: auto; display: block; margin: 20px auto; cursor: grab; }
        .webcam-preview { margin-top: 20px; }
        #webcamFeed { width: 300px; height: auto; border: 2px solid #333; display: block; margin: 10px auto; }
        .controls-panel { flex: 1; background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        .control-group { border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 4px; }
        legend { font-weight: bold; color: #007bff; padding: 0 10px; }
        .control-group > div { margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; }
        .control-group > div:not(:last-child) { margin-bottom: 10px; }
        
        /* Input styling */
        input[type="range"] { flex-grow: 1; margin-left: 10px; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input[type="text"], 
        .control-group input[type="number"],
        .control-group input[type="color"], 
        .control-group select { flex-grow: 1; margin-left: 10px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .control-group input[type="color"] { width: 40px; height: 30px; padding: 0; }
        
        /* Specific elements */
        #capturePhotoBtn { background-color: #ffc107; color: #333; }
        #capturePhotoBtn:hover { background-color: #e0a800; }
        #stickerLibrary { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; margin-bottom: 15px; }
        .predefined-sticker { width: 40px; height: 40px; background-color: #eee; font-size: 1.2em; padding: 0; }
        #newDesignBtnDesign { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        #newDesignBtnDesign:hover { background-color: #0056b3; }
        
        /* Font Previews (cho select) */
        .font-arial { font-family: Arial, sans-serif; }
        .font-dancing { font-family: 'Dancing Script', cursive; }
        .font-pacifico { font-family: 'Pacifico', cursive; }
        .font-pinyon { font-family: 'Pinyon Script', cursive; }
        .font-montserrat { font-family: 'Montserrat', sans-serif; }


        /* ==================== CH·∫æ ƒê·ªò TH∆Ø VI·ªÜN (LIBRARY MODE) ==================== */
        #library-view { display: none; padding: 20px; text-align: center; }
        .design-list { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-top: 30px; }
        .design-card { background-color: white; border: 1px solid #ddd; border-radius: 8px; padding: 15px; width: 280px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05); }
        .design-card h3 { color: #007bff; margin-top: 0; }
        .design-card p { font-size: 0.9em; color: #666; }
        .action-group button { margin-top: 10px; padding: 8px 15px; width: 48%; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; }
        .load-btn { background-color: #28a745; color: white; }
        .delete-btn { background-color: #dc3545; color: white; margin-left: 5px; }
        #newDesignBtnLib { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 20px; }
        #newDesignBtnLib:hover { background-color: #0056b3; }
        
        /* Responsive */
        @media (max-width: 768px) {
            #design-view { flex-direction: column; }
            .design-area { padding-right: 0; padding-bottom: 20px; }
            .design-area > div { display: flex; flex-direction: row; gap: 10px; }
            .design-area button { flex-grow: 1; }
        }
    </style>
</head>
<body>

    <header>
        <h1 id="main-title">T·∫°o Strip Photo Booth C√° Nh√¢n</h1>
    </header>

    <div id="design-view">
        <section class="design-area">
            <div id="designer-actions-top" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button id="toggleViewBtn" class="secondary-action" style="width: auto;" onclick="showLibrary()">
                    ‚Üê Quay l·∫°i Th∆∞ Vi·ªán Thi·∫øt K·∫ø
                </button>
                <button id="newDesignBtnDesign" class="secondary-action" style="width: auto; flex-grow: 1; background-color: #007bff;" onclick="showDesign(true)">
                    **+ T·∫°o Thi·∫øt K·∫ø M·ªõi**
                </button>
            </div>
            <h2 id="canvas-header">Khung Xem Tr∆∞·ªõc Strip 4 ·∫¢nh (B·∫•m chu·ªôt ph·∫£i ƒë·ªÉ X√≥a ƒë·ªëi t∆∞·ª£ng)</h2>
            <canvas id="photoStripCanvas" width="600" height="1800">
                Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ Canvas.
            </canvas>
            <div class="webcam-preview">
                <video id="webcamFeed" autoplay></video>
                <button id="capturePhotoBtn">Ch·ª•p ·∫¢nh (1/4)</button>
            </div>
        </section>

        <aside id="controls-panel" class="controls-panel">
            <h2>üõ†Ô∏è C√¥ng C·ª• Thi·∫øt K·∫ø</h2>

            <fieldset class="control-group">
                <legend>T√πy Ch·ªânh C∆° B·∫£n</legend>
                <div><label for="frameColor">M√†u Khung/Vi·ªÅn:</label><input type="color" id="frameColor" value="#000000"></div>
                <div><label for="frameThickness">ƒê·ªô D√†y Khung (px):</label><input type="range" id="frameThickness" min="5" max="100" value="25"><span id="thicknessValue">25px</span></div>
                <div><label for="photoSizeScale">T·ª∑ L·ªá K√≠ch C·ª° ·∫¢nh:</label><input type="range" id="photoSizeScale" min="0.5" max="1.5" step="0.05" value="1.0"><span id="sizeValue">100%</span></div>
                <div><label for="stripWidth">ƒê·ªô R·ªông Strip (px):</label><input type="number" id="stripWidth" value="600" min="100"></div>
                <div><label for="stripHeight">ƒê·ªô D√†i Strip (px):</label><input type="number" id="stripHeight" value="1800" min="300"></div>
            </fieldset>

            <fieldset class="control-group">
                <legend>T·∫£i L√™n ·∫¢nh C√° Nh√¢n/Idol</legend>
                <div><input type="file" id="imageUpload" accept="image/*" style="width: 60%;"><button id="addImageToStripBtn" style="width: 40%; margin-top: 0;">Th√™m ·∫¢nh</button></div>
            </fieldset>
            
            <fieldset class="control-group">
                <legend>Th√™m Ch·ªØ / Ch·ªØ K√Ω</legend>
                <div><label for="textInput">VƒÉn b·∫£n:</label><input type="text" id="textInput" placeholder="Nh·∫≠p ch·ªØ/ch·ªØ k√Ω"></div>
                <div>
                    <label for="fontSelect">Font:</label>
                    <select id="fontSelect">
                        <option value="Montserrat" class="font-montserrat">Montserrat (Hi·ªán ƒë·∫°i)</option>
                        <option value="Arial" class="font-arial">Arial (C∆° b·∫£n)</option>
                        <option value="Dancing Script" class="font-dancing">Dancing Script (Vi·∫øt tay)</option>
                        <option value="Pacifico" class="font-pacifico">Pacifico (C·ªï ƒëi·ªÉn)</option>
                        <option value="Pinyon Script" class="font-pinyon">Pinyon Script (Ngh·ªá thu·∫≠t)</option>
                    </select>
                </div>
                <div><label for="textColor">M√†u ch·ªØ:</label><input type="color" id="textColor" value="#000000"></div>
                <div><label for="fontSize">K√≠ch th∆∞·ªõc:</label><input type="range" id="fontSize" min="10" max="100" value="40"><span id="fontSizeValue">40px</span></div>
                <button id="addTextToStripBtn">Th√™m Ch·ªØ</button>
            </fieldset>

            <fieldset class="control-group">
                <legend>Th∆∞ Vi·ªán Sticker</legend>
                <div id="stickerLibrary">
                    <button class="predefined-sticker" data-sticker-url="https://raw.githubusercontent.com/google/material-design-icons/master/png/social/star_black/1x_web/baseline_star_black_24dp.png">‚≠ê</button>
                    <button class="predefined-sticker" data-sticker-url="https://www.freeiconspng.com/uploads/red-heart-png-27.png">üíñ</button>
                    <button class="predefined-sticker" data-sticker-url="https://cdn-icons-png.flaticon.com/512/32/32185.png">üß¢</button>
                    <button class="predefined-sticker" data-sticker-url="https://www.freeiconspng.com/uploads/glasses-png-22.png">üï∂Ô∏è</button>
                </div>
                <div><label>T·∫£i Th√™m Sticker M·ªõi (.png/jpg):</label><input type="file" id="customStickerUpload" accept="image/*" style="width: 60%;"><button id="addCustomStickerBtn" style="width: 40%; margin-top: 0;">Th√™m Sticker</button></div>
            </fieldset>
            
            <fieldset class="control-group">
                <legend>ƒêi·ªÅu Ch·ªânh L·ªõp (Layer)</legend>
                <div>
                    <button id="bringForwardBtn" class="secondary-action" style="width: 49%; background-color: #ffc107; color: #333; margin-top: 0;">L√™n m·ªôt l·ªõp (‚¨Ü)</button>
                    <button id="sendBackwardBtn" class="secondary-action" style="width: 49%; background-color: #17a2b8; margin-top: 0;">Xu·ªëng m·ªôt l·ªõp (‚¨á)</button>
                </div>
                <div>
                    <button id="bringToFrontBtn" class="primary-action" style="width: 49%; margin-top: 5px;">L√™n tr√™n c√πng (‚è´)</button>
                    <button id="sendToBackBtn" class="secondary-action" style="width: 49%; background-color: #dc3545; margin-top: 5px;">Xu·ªëng d∆∞·ªõi c√πng (‚è¨)</button>
                </div>
                <div class="alert-message" id="layerControlAlert" style="display: none; margin-top: 10px; margin-bottom: 0;">
                    Vui l√≤ng ch·ªçn m·ªôt ƒë·ªëi t∆∞·ª£ng (·∫£nh, sticker, ch·ªØ) tr√™n canvas.
                </div>
            </fieldset>
            <fieldset class="control-group">
                <legend>L∆∞u v√† Chia S·∫ª M·∫´u</legend>
                
                <label for="designUpload" class="secondary-action" style="display: block; text-align: center; margin-bottom: 10px; background-color: #6c757d; color: white;">
                    **T·∫£i M·∫´u Thi·∫øt K·∫ø (File .json)**
                </label>
                <input type="file" id="designUpload" accept=".json" style="display: none;">
                
                <button id="saveDesignBtn" class="primary-action" style="background-color: #007bff;">L∆∞u Thi·∫øt K·∫ø & T·∫£i File .json</button>
                <button id="exportShareLinkBtn" class="secondary-action">Xu·∫•t Link Chia S·∫ª (ƒê√£ nh√∫ng d·ªØ li·ªáu)</button>
            </fieldset>

            <button id="exportFinalImageBtn" class="primary-action">Xu·∫•t Strip ·∫¢nh Ho√†n Ch·ªânh (T·∫£i v·ªÅ)</button>
        </aside>
    </div>

    <div id="library-view">
        <h1>üìö Th∆∞ Vi·ªán M·∫´u Thi·∫øt K·∫ø C·ªßa T√¥i</h1>
        <div class="alert-message">
            **L∆ØU √ù:** B·∫°n c√≥ th·ªÉ chia s·∫ª m·∫´u thi·∫øt k·∫ø b·∫±ng **Link Chia S·∫ª** (y√™u c·∫ßu host web nh∆∞ GitHub Pages) ho·∫∑c chia s·∫ª file **.json** (c√≥ th·ªÉ d√πng c·ª•c b·ªô).
        </div>
        <button id="newDesignBtnLib" onclick="showDesign(true)">+ T·∫°o M·∫´u Thi·∫øt K·∫ø M·ªõi</button>
        <div id="designList" class="design-list">
            <p>ƒêang t·∫£i th∆∞ vi·ªán...</p>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 Photo Booth Designer C·ªßa B·∫°n</p>
    </footer>

    <script>
        // Khai b√°o c√°c bi·∫øn DOM v√† h·∫±ng s·ªë
        const designView = document.getElementById('design-view');
        const libraryView = document.getElementById('library-view');
        const mainTitle = document.getElementById('main-title');

        const canvas = document.getElementById('photoStripCanvas');
        const ctx = canvas.getContext('2d');
        const webcamFeed = document.getElementById('webcamFeed');
        const capturePhotoBtn = document.getElementById('capturePhotoBtn');
        const exportFinalImageBtn = document.getElementById('exportFinalImageBtn');
        const frameColorInput = document.getElementById('frameColor');
        const frameThicknessInput = document.getElementById('frameThickness');
        const thicknessValueSpan = document.getElementById('thicknessValue');
        const photoSizeScaleInput = document.getElementById('photoSizeScale');
        const sizeValueSpan = document.getElementById('sizeValue');
        const stripWidthInput = document.getElementById('stripWidth');
        const stripHeightInput = document.getElementById('stripHeight');
        
        const imageUpload = document.getElementById('imageUpload');
        const addImageToStripBtn = document.getElementById('addImageToStripBtn');
        const stickerLibrary = document.getElementById('stickerLibrary');
        const customStickerUpload = document.getElementById('customStickerUpload');
        const addCustomStickerBtn = document.getElementById('addCustomStickerBtn');
        
        const designList = document.getElementById('designList');

        // Text Controls
        const textInput = document.getElementById('textInput');
        const fontSelect = document.getElementById('fontSelect');
        const textColorInput = document.getElementById('textColor');
        const fontSizeInput = document.getElementById('fontSize');
        const fontSizeValueSpan = document.getElementById('fontSizeValue');
        const addTextToStripBtn = document.getElementById('addTextToStripBtn');
        const saveDesignBtn = document.getElementById('saveDesignBtn');
        const exportShareLinkBtn = document.getElementById('exportShareLinkBtn');
        
        // Design File Upload
        const designUpload = document.getElementById('designUpload');
        
        // Layer Controls
        const bringForwardBtn = document.getElementById('bringForwardBtn');
        const sendBackwardBtn = document.getElementById('sendBackwardBtn');
        const bringToFrontBtn = document.getElementById('bringToFrontBtn');
        const sendToBackBtn = document.getElementById('sendToBackBtn');
        const layerControlAlert = document.getElementById('layerControlAlert');
        
        // C√ÅC PH·∫¶N T·ª¨ M·ªöI ƒê∆Ø·ª¢C CH·ªåN CHO VIEWER MODE
        const controlsPanel = document.getElementById('controls-panel');
        const designerActionsTop = document.getElementById('designer-actions-top');
        const toggleViewBtn = document.getElementById('toggleViewBtn');
        const canvasHeader = document.getElementById('canvas-header');


        const MAX_PHOTOS = 4;

        let capturedPhotos = []; 
        let currentPhotoIndex = 0;
        let canvasObjects = []; 

        let isDragging = false;
        let isResizing = false;
        let isRotating = false; 
        let selectedObject = null;
        let startX;
        let startY;
        let lastAngle = 0; 
        let currentDesignId = null;

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i hi·ªÉn th·ªã c·ªßa n√∫t Layer Control
        function updateLayerControls() {
            if (selectedObject) {
                layerControlAlert.style.display = 'none';
                bringForwardBtn.disabled = false;
                sendBackwardBtn.disabled = false;
                bringToFrontBtn.disabled = false;
                sendToBackBtn.disabled = false;
            } else {
                layerControlAlert.style.display = 'block';
                bringForwardBtn.disabled = true;
                sendBackwardBtn.disabled = true;
                bringToFrontBtn.disabled = true;
                sendToBackBtn.disabled = true;
            }
        }


        canvas.addEventListener('contextmenu', (e) => {
            // Ch·ªâ cho ph√©p x√≥a khi ƒëang ·ªü Designer Mode
            if (controlsPanel.style.display === 'none') return;
            
            e.preventDefault(); 
            if (selectedObject) {
                 if (confirm("B·∫°n c√≥ mu·ªën x√≥a ƒë·ªëi t∆∞·ª£ng ƒë√£ ch·ªçn n√†y kh√¥ng?")) {
                    canvasObjects = canvasObjects.filter(obj => obj !== selectedObject);
                    selectedObject = null;
                    drawFrame();
                    updateLayerControls();
                 }
            }
        });


        // =======================================================
        // PH·∫¶N 1: KH·ªûI T·∫†O V√Ä V·∫º CANVAS
        // =======================================================

        async function startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                webcamFeed.srcObject = stream;
                webcamFeed.style.display = 'block';
                capturePhotoBtn.style.display = 'block';
            } catch (error) {
                console.error("Kh√¥ng th·ªÉ truy c·∫≠p webcam:", error);
                alert("Kh√¥ng th·ªÉ truy c·∫≠p Webcam. Vui l√≤ng s·ª≠ d·ª•ng t√≠nh nƒÉng 'T·∫£i L√™n ·∫¢nh C√° Nh√¢n/Idol'.");
                webcamFeed.style.display = 'none';
                capturePhotoBtn.style.display = 'none';
            }
        }

        function updateCaptureButtonText() {
            if (currentPhotoIndex < MAX_PHOTOS) {
                capturePhotoBtn.textContent = `Ch·ª•p ·∫¢nh (${currentPhotoIndex + 1}/${MAX_PHOTOS})`;
                capturePhotoBtn.disabled = false;
            } else {
                capturePhotoBtn.textContent = `HO√ÄN T·∫§T CH·ª§P! (S·∫µn s√†ng Xu·∫•t ·∫¢nh)`;
                capturePhotoBtn.disabled = true;
            }
        }
        
        function capturePhoto() {
            if (currentPhotoIndex >= MAX_PHOTOS) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = webcamFeed.videoWidth;
            tempCanvas.height = webcamFeed.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(webcamFeed, 0, 0, tempCanvas.width, tempCanvas.height);

            const capturedImage = new Image();
            capturedImage.onload = () => {
                capturedPhotos[currentPhotoIndex] = {
                    index: currentPhotoIndex,
                    image: capturedImage,
                    src: tempCanvas.toDataURL('image/png') 
                };
                currentPhotoIndex++;
                updateCaptureButtonText();
                drawFrame(); 
            };
            capturedImage.src = tempCanvas.toDataURL('image/png');
        }


        function drawFrame() {
            const scale = parseFloat(photoSizeScaleInput.value);
            const thickness = parseInt(frameThicknessInput.value);
            
            let currentWidth = parseFloat(stripWidthInput.value);
            let currentHeight = parseFloat(stripHeightInput.value);

            currentWidth = Math.max(100, currentWidth);
            currentHeight = Math.max(300, currentHeight);
            stripWidthInput.value = currentWidth.toFixed(0);
            stripHeightInput.value = currentHeight.toFixed(0);

            canvas.width = currentWidth;
            canvas.height = currentHeight;
            thicknessValueSpan.textContent = `${thickness}px`;
            sizeValueSpan.textContent = `${(scale * 100).toFixed(0)}%`;
            fontSizeValueSpan.textContent = `${fontSizeInput.value}px`; 


            ctx.clearRect(0, 0, currentWidth, currentHeight);
            ctx.fillStyle = frameColorInput.value;
            ctx.fillRect(0, 0, currentWidth, currentHeight);

            const photoWidth = currentWidth - 2 * thickness;
            const photoHeight = (currentHeight - (MAX_PHOTOS + 1) * thickness) / MAX_PHOTOS; 

            if (photoWidth <= 0 || photoHeight <= 0) {
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.fillText('K√≠ch th∆∞·ªõc khung qu√° l·ªõn!', currentWidth / 2, currentHeight / 2);
                return;
            }

            for (let i = 0; i < MAX_PHOTOS; i++) {
                const x = thickness;
                const y = thickness + i * (photoHeight + thickness); 

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y, photoWidth, photoHeight);

                if (capturedPhotos[i] && capturedPhotos[i].image) {
                    const img = capturedPhotos[i].image;
                    const imgW = img.width;
                    const imgH = img.height;
                    const hRatio = photoWidth / imgW;
                    const vRatio = photoHeight / imgH;
                    const ratio = Math.max(hRatio, vRatio); 
                    
                    const drawW = imgW * ratio;
                    const drawH = imgH * ratio;
                    const drawX = x + (photoWidth - drawW) / 2;
                    const drawY = y + (photoHeight - drawH) / 2;
                    
                    ctx.drawImage(img, drawX, drawY, drawW, drawH);
                } else {
                    ctx.fillStyle = 'gray';
                    ctx.font = '30px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`·∫¢nh ${i + 1} CH∆ØA CH·ª§P`, x + photoWidth / 2, y + photoHeight / 2);
                }
            }
            
            // V·∫º C√ÅC STICKER/·∫¢NH/TEXT T·∫£i l√™n
            canvasObjects.forEach(obj => {
                ctx.save();
                
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                ctx.translate(centerX, centerY);
                ctx.rotate(obj.angle || 0); 
                ctx.translate(-centerX, -centerY); 

                if (obj.type === 'image' || obj.type === 'sticker') {
                    ctx.drawImage(obj.image, obj.x, obj.y, obj.width, obj.height);
                } else if (obj.type === 'text') {
                    // S·ª≠ d·ª•ng font Google
                    ctx.font = `${obj.fontSize}px "${obj.fontFamily}", sans-serif`;
                    ctx.fillStyle = obj.textColor;
                    ctx.textAlign = obj.textAlign;
                    ctx.textBaseline = obj.textBaseline;

                    const metrics = ctx.measureText(obj.text);
                    obj.width = metrics.width;
                    obj.height = obj.fontSize;
                    
                    ctx.fillText(obj.text, obj.x, obj.y + obj.fontSize * 0.75);
                }
                
                // V·∫Ω vi·ªÅn v√† ƒëi·ªÉm ƒëi·ªÅu khi·ªÉn ch·ªâ khi ·ªü Designer Mode V√Ä ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c ch·ªçn
                if (controlsPanel.style.display !== 'none' && obj === selectedObject) {
                    ctx.strokeStyle = '#FF00FF'; 
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                    
                    const controlPointSize = 10;
                    
                    ctx.fillStyle = '#00FFFF';
                    ctx.fillRect(obj.x + obj.width - controlPointSize / 2, 
                                 obj.y + obj.height - controlPointSize / 2, 
                                 controlPointSize, controlPointSize);
                    
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(obj.x - controlPointSize / 2, 
                                 obj.y - controlPointSize / 2, 
                                 controlPointSize, controlPointSize);
                }
                ctx.restore(); 
            });
        }

        // =======================================================
        // PH·∫¶N 2: LOGIC TH√äM ·∫¢NH/STICKER/TEXT
        // =======================================================

        function handleImageAdd(source, name, type, positionData = null) {
            const img = new Image();
            img.onload = () => {
                const defaultSize = 150; 
                let aspectRatio = 1;

                if (img.width > 0 && img.height > 0) {
                    aspectRatio = img.height / img.width;
                }

                let initialWidth = defaultSize;
                if (img.width > canvas.width) {
                    initialWidth = canvas.width / 4;
                    aspectRatio = img.height / img.width;
                }

                const newObject = {
                    name: name,
                    type: type, 
                    image: img,
                    src: source, 
                    x: positionData ? positionData.x : canvas.width / 2 - initialWidth / 2, 
                    y: positionData ? positionData.y : canvas.height / 2 - initialWidth / 2,
                    width: positionData ? positionData.width : initialWidth,
                    height: positionData ? positionData.height : initialWidth * aspectRatio,
                    angle: positionData ? positionData.angle : 0, 
                };
                
                canvasObjects.push(newObject);
                selectedObject = newObject; 
                drawFrame(); 
                updateLayerControls();
            };
            img.onerror = () => {
                console.error(`Kh√¥ng th·ªÉ t·∫£i ${type}: ${name}. Source: ${source}`);
                alert(`L·ªói: Kh√¥ng th·ªÉ t·∫£i ${type} "${name}". Vui l√≤ng ki·ªÉm tra file ho·∫∑c ƒë∆∞·ªùng d·∫´n.`);
            };
            
            if (source.startsWith('http') && !source.startsWith(window.location.origin)) {
                img.crossOrigin = "Anonymous";
            }
            img.src = source;
        }

        function handleTextAdd() {
            const text = textInput.value;
            const font = fontSelect.value;
            const color = textColorInput.value;
            const size = parseInt(fontSizeInput.value);

            if (!text.trim()) {
                alert("Vui l√≤ng nh·∫≠p vƒÉn b·∫£n ho·∫∑c ch·ªØ k√Ω.");
                return;
            }

            const newObject = {
                name: text,
                type: 'text',
                text: text,
                fontFamily: font,
                textColor: color,
                fontSize: size,
                x: canvas.width / 2, 
                y: canvas.height / 2,
                width: 0, 
                height: 0, 
                angle: 0,
                textAlign: 'center', 
                textBaseline: 'middle' 
            };
            canvasObjects.push(newObject);
            selectedObject = newObject; 
            drawFrame(); 
            updateLayerControls();
            textInput.value = '';
        }

        // =======================================================
        // PH·∫¶N 3: LOGIC K√âO, TH·∫¢, RESIZING, ROTATING & LAYER
        // =======================================================

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }
        
        function isPointInObject(x, y, obj) {
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;

            const cos = Math.cos(-obj.angle);
            const sin = Math.sin(-obj.angle);
            
            const rotatedX = cos * (x - centerX) - sin * (y - centerY) + centerX;
            const rotatedY = sin * (x - centerX) + cos * (y - centerY) + centerY;

            return rotatedX >= obj.x && rotatedX <= obj.x + obj.width &&
                   rotatedY >= obj.y && rotatedY <= obj.y + obj.height;
        }
        
        function isPointInResizeHandle(x, y, obj) {
            const controlPointSize = 10;
            const handleX = obj.x + obj.width - controlPointSize / 2;
            const handleY = obj.y + obj.height - controlPointSize / 2;
            
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;

            const cos = Math.cos(obj.angle);
            const sin = Math.sin(obj.angle);

            const rotatedHandleX = cos * (handleX - centerX) - sin * (handleY - centerY) + centerX;
            const rotatedHandleY = sin * (handleX - centerX) + cos * (handleY - centerY) + centerY;

            return x >= rotatedHandleX - 5 && x <= rotatedHandleX + controlPointSize + 5 &&
                   y >= rotatedHandleY - 5 && y <= rotatedHandleY + controlPointSize + 5;
        }

        function isPointInRotateHandle(x, y, obj) {
            const controlPointSize = 10;
            const handleX = obj.x - controlPointSize / 2;
            const handleY = obj.y - controlPointSize / 2;

            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;

            const cos = Math.cos(obj.angle);
            const sin = Math.sin(obj.angle);

            const rotatedHandleX = cos * (handleX - centerX) - sin * (handleY - centerY) + centerX;
            const rotatedHandleY = sin * (handleX - centerX) + cos * (handleY - centerY) + centerY;

            return x >= rotatedHandleX - 5 && x <= rotatedHandleX + controlPointSize + 5 &&
                   y >= rotatedHandleY - 5 && y <= rotatedHandleY + controlPointSize + 5;
        }

        function handleMouseDown(e) {
            // Ch·ªâ cho ph√©p t∆∞∆°ng t√°c khi ·ªü Designer Mode
            if (controlsPanel.style.display === 'none') return;
            
            const mousePos = getMousePos(e);
            let foundObject = null;
            isResizing = false;
            isRotating = false;
            
            selectedObject = null; 

            for (let i = canvasObjects.length - 1; i >= 0; i--) {
                const obj = canvasObjects[i];
                
                if (isPointInRotateHandle(mousePos.x, mousePos.y, obj)) {
                    selectedObject = obj;
                    isRotating = true;
                    isDragging = true; 
                    startX = mousePos.x;
                    startY = mousePos.y;
                    lastAngle = obj.angle || 0; 
                    drawFrame(); 
                    updateLayerControls();
                    return;
                }

                if (isPointInResizeHandle(mousePos.x, mousePos.y, obj)) {
                    selectedObject = obj;
                    isResizing = true;
                    isDragging = true;
                    startX = mousePos.x;
                    startY = mousePos.y;
                    drawFrame();
                    updateLayerControls();
                    return;
                }

                if (isPointInObject(mousePos.x, mousePos.y, obj)) {
                    canvasObjects.splice(i, 1);
                    canvasObjects.push(obj);
                    foundObject = obj;
                    break;
                }
            }

            if (foundObject) {
                selectedObject = foundObject;
                isDragging = true;
                startX = mousePos.x;
                startY = mousePos.y;
                drawFrame(); 
            }
            
            updateLayerControls(); 
        }

        function handleMouseMove(e) {
            if (controlsPanel.style.display === 'none') return;
            if (!isDragging || !selectedObject) {
                return;
            }

            const mousePos = getMousePos(e);
            const dx = mousePos.x - startX;
            const dy = mousePos.y - startY;

            if (isResizing) {
                if (selectedObject.type === 'image' || selectedObject.type === 'sticker') {
                    if (selectedObject.image && selectedObject.image.width > 0) {
                        const aspectRatio = selectedObject.image.height / selectedObject.image.width;
                        let newWidth = selectedObject.width + dx;
                        if (newWidth < 20) newWidth = 20; 
                        selectedObject.width = newWidth;
                        selectedObject.height = newWidth * aspectRatio;
                    }
                } else if (selectedObject.type === 'text') {
                    let newSize = selectedObject.fontSize + dy / 2; 
                    if (newSize < 10) newSize = 10;
                    selectedObject.fontSize = newSize; 
                }
                
                startX = mousePos.x;
                startY = mousePos.y;
            } else if (isRotating) {
                const centerX = selectedObject.x + selectedObject.width / 2;
                const centerY = selectedObject.y + selectedObject.height / 2;
                
                const currentAngle = Math.atan2(mousePos.y - centerY, mousePos.x - centerX);
                const startAngle = Math.atan2(startY - centerY, startX - centerX);
                
                const deltaAngle = currentAngle - startAngle;
                selectedObject.angle = lastAngle + deltaAngle;
                
            } else {
                selectedObject.x += dx;
                selectedObject.y += dy;
                
                startX = mousePos.x;
                startY = mousePos.y;
            }

            drawFrame();
        }

        function handleMouseUp() {
            if (controlsPanel.style.display === 'none') return;
            if (isRotating && selectedObject) {
                lastAngle = selectedObject.angle || 0; 
            }
            isDragging = false;
            isResizing = false;
            isRotating = false;
        }

        function adjustLayer(direction) {
            if (!selectedObject) {
                alert("Vui l√≤ng ch·ªçn m·ªôt ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ ƒëi·ªÅu ch·ªânh l·ªõp.");
                return;
            }

            const currentIndex = canvasObjects.findIndex(obj => obj === selectedObject);
            if (currentIndex === -1) return;

            if (direction === 'up' && currentIndex < canvasObjects.length - 1) {
                [canvasObjects[currentIndex], canvasObjects[currentIndex + 1]] = [canvasObjects[currentIndex + 1], canvasObjects[currentIndex]];
            } else if (direction === 'down' && currentIndex > 0) {
                [canvasObjects[currentIndex], canvasObjects[currentIndex - 1]] = [canvasObjects[currentIndex - 1], canvasObjects[currentIndex]];
            } else if (direction === 'front') {
                canvasObjects.splice(currentIndex, 1);
                canvasObjects.push(selectedObject);
            } else if (direction === 'back') {
                canvasObjects.splice(currentIndex, 1);
                canvasObjects.unshift(selectedObject);
            }

            drawFrame();
        }

        // =======================================================
        // PH·∫¶N 4: LOGIC L∆ØU/T·∫¢I/XU·∫§T V√Ä CHUY·ªÇN CH·∫æ ƒê·ªò
        // =======================================================
        
        // H√ÄM M·ªöI: ·∫®N/HI·ªÜN CONTROLS T√ôY THEO CH·∫æ ƒê·ªò
        function toggleDesignerControls(show) {
            if (show) {
                // Hi·ªÉn th·ªã t·∫•t c·∫£ c√°c controls thi·∫øt k·∫ø (ch·∫ø ƒë·ªô Designer)
                controlsPanel.style.display = 'block';
                designerActionsTop.style.display = 'flex';
                canvasHeader.textContent = "Khung Xem Tr∆∞·ªõc Strip 4 ·∫¢nh (B·∫•m chu·ªôt ph·∫£i ƒë·ªÉ X√≥a ƒë·ªëi t∆∞·ª£ng)";
                mainTitle.textContent = "T·∫°o Strip Photo Booth C√° Nh√¢n";
            } else {
                // ·∫®n t·∫•t c·∫£ c√°c controls thi·∫øt k·∫ø (ch·∫ø ƒë·ªô Viewer/User)
                controlsPanel.style.display = 'none';
                designerActionsTop.style.display = 'none'; // ·∫®n n√∫t Quay l·∫°i th∆∞ vi·ªán v√† T·∫°o m·ªõi
                canvasHeader.textContent = "Khung ·∫¢nh Strip Photobooth C·ªßa B·∫°n";
                mainTitle.textContent = "S·ª≠ D·ª•ng M·∫´u Photobooth";

                // Ch·ªâ hi·ªán n√∫t Xu·∫•t ·∫¢nh Ho√†n Ch·ªânh trong Designer mode n·∫øu n√≥ b·ªã ·∫©n
                exportFinalImageBtn.style.display = 'block'; 
            }
        }


        function loadDesigns() {
            // ... (Logic t·∫£i designs t·ª´ Local Storage kh√¥ng ƒë·ªïi) ...
            const savedDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
            designList.innerHTML = '';
            
            if (savedDesigns.length === 0) {
                 designList.innerHTML = '<p>Ch∆∞a c√≥ thi·∫øt k·∫ø n√†o ƒë∆∞·ª£c l∆∞u. B·∫•m **+ T·∫°o M·∫´u Thi·∫øt K·∫ø M·ªõi** ƒë·ªÉ b·∫Øt ƒë·∫ßu!</p>';
                 return;
            }
            
            savedDesigns.forEach((design, index) => {
                const card = document.createElement('div');
                card.className = 'design-card';
                card.innerHTML = `
                    <h3>${design.name || `M·∫´u Photobooth ${new Date(design.timestamp).toLocaleDateString('vi-VN')}`}</h3>
                    <p>ID: ${design.id}</p>
                    <p>L∆∞u l√∫c: ${new Date(design.timestamp).toLocaleTimeString('vi-VN')}</p>
                    <div class="action-group">
                        <button class="load-btn" onclick="loadDesignByIndex(${index})">T·∫£i & Ch·ªânh S·ª≠a</button>
                        <button class="delete-btn" onclick="deleteDesignByIndex(${index})">X√≥a</button>
                    </div>
                `;
                designList.appendChild(card);
            });
        }

        function showLibrary() {
            designView.style.display = 'none';
            libraryView.style.display = 'block'; 
            
            toggleDesignerControls(true); // Lu√¥n B·∫≠t Designer Controls khi ·ªü Library
            loadDesigns(); 
            
            if (webcamFeed.srcObject) {
                webcamFeed.srcObject.getTracks().forEach(track => track.stop());
                webcamFeed.srcObject = null;
            }
        }


        function showDesign(isNew = false, designData = null) {
            designView.style.display = 'flex';
            libraryView.style.display = 'none';
            currentDesignId = null; 
            selectedObject = null;
            
            // LU√îN B·∫¨T CONTROLS V√ÄO L√öC N√ÄY, LOGIC T·∫ÆT S·∫º ·ªû window.onload HO·∫∂C showLibrary/loadDesign
            toggleDesignerControls(true); 

            if (isNew) {
                capturedPhotos = [];
                currentPhotoIndex = 0;
                canvasObjects = [];
                frameColorInput.value = '#000000';
                frameThicknessInput.value = '25';
                photoSizeScaleInput.value = '1.0';
                stripWidthInput.value = '600';
                stripHeightInput.value = '1800';
                
                currentDesignId = Math.random().toString(36).substring(2, 9);
            }

            if (designData) {
                currentDesignId = designData.id || Math.random().toString(36).substring(2, 9);
                frameColorInput.value = designData.settings.frameColor || '#000000';
                frameThicknessInput.value = designData.settings.frameThickness || '25';
                photoSizeScaleInput.value = designData.settings.photoSizeScale || '1.0';
                stripWidthInput.value = designData.settings.stripWidth || '600';
                stripHeightInput.value = designData.settings.stripHeight || '1800';
                
                capturedPhotos = [];
                currentPhotoIndex = 0;
                if (designData.photos && designData.photos.length) {
                    designData.photos.forEach((photoData, index) => {
                        if (photoData && photoData.src) {
                            const img = new Image();
                            img.onload = () => {
                                capturedPhotos[index] = { index: index, image: img, src: photoData.src };
                                currentPhotoIndex = Math.max(currentPhotoIndex, index + 1);
                                updateCaptureButtonText();
                                drawFrame();
                            };
                            img.crossOrigin = "Anonymous";
                            img.src = photoData.src;
                        }
                    });
                }
                
                canvasObjects = [];
                let loadCount = 0;
                const totalObjects = designData.objects.length;
                
                const finishLoading = () => {
                    loadCount++;
                    if (loadCount === totalObjects || totalObjects === 0) {
                        drawFrame();
                        // Ch·ªâ hi·ªán th√¥ng b√°o khi t·∫£i t·ª´ Local Storage/File
                        if (!window.location.hash.substring(1)) {
                            alert(`Thi·∫øt k·∫ø "${designData.name || currentDesignId}" ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng!`);
                        }
                    }
                };

                designData.objects.forEach(objData => {
                    if (objData.type === 'text') {
                        canvasObjects.push(objData);
                        finishLoading();
                    } else if (objData.src) {
                        const img = new Image();
                        img.onload = () => {
                            canvasObjects.push({...objData, image: img});
                            finishLoading();
                        };
                        img.onerror = finishLoading; 
                        img.crossOrigin = "Anonymous"; 
                        img.src = objData.src;
                    } else {
                        finishLoading(); // B·ªè qua ƒë·ªëi t∆∞·ª£ng kh√¥ng c√≥ src (v√≠ d·ª•: b·ªã l·ªói)
                    }
                });
            }

            drawFrame();
            updateCaptureButtonText();
            updateLayerControls();
            if (!webcamFeed.srcObject || !webcamFeed.srcObject.active) {
                startWebcam();
            }
        }
        
        // H√†m L∆∞u Thi·∫øt K·∫ø & T·∫£i File JSON
        function saveDesign() {
            // ... (Logic L∆∞u kh√¥ng ƒë·ªïi) ...
            if (!currentDesignId) {
                currentDesignId = Math.random().toString(36).substring(2, 9);
            }

            const designName = prompt("Nh·∫≠p t√™n cho m·∫´u thi·∫øt k·∫ø n√†y:", `M·∫´u Photobooth ${new Date().toLocaleDateString('vi-VN')}`);
            if (!designName) return;

            const savedDesignData = {
                id: currentDesignId,
                name: designName,
                timestamp: Date.now(),
                settings: {
                    frameColor: frameColorInput.value,
                    frameThickness: frameThicknessInput.value,
                    photoSizeScale: photoSizeScaleInput.value,
                    stripWidth: stripWidthInput.value,
                    stripHeight: stripHeightInput.value,
                },
                photos: capturedPhotos.map(p => (p ? { src: p.src } : null)), 
                objects: canvasObjects.map(obj => {
                    if (obj.type !== 'text') {
                        const { image, ...rest } = obj;
                        return rest;
                    }
                    return obj;
                })
            };

            // 1. L∆∞u v√†o Local Storage
            let allDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
            const existingIndex = allDesigns.findIndex(d => d.id === currentDesignId);

            if (existingIndex > -1) {
                allDesigns[existingIndex] = savedDesignData;
            } else {
                allDesigns.push(savedDesignData);
            }

            localStorage.setItem('photoBoothDesigns', JSON.stringify(allDesigns));
            
            // 2. T·∫¢I XU·ªêNG FILE JSON
            const jsonString = JSON.stringify(savedDesignData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${designName.replace(/[^a-z0-9]/gi, '_')}.photobooth.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            alert(`‚úÖ Thi·∫øt k·∫ø "${designName}" ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o Th∆∞ Vi·ªán v√† t·∫£i xu·ªëng th√†nh file .json! B·∫°n c√≥ th·ªÉ g·ª≠i file n√†y cho ng∆∞·ªùi kh√°c.`);
        }
        
        // H√†m x·ª≠ l√Ω T·∫£i File JSON
        function handleDesignUpload(file) {
            // ... (Logic T·∫£i File kh√¥ng ƒë·ªïi) ...
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const designData = JSON.parse(e.target.result);
                    if (designData && designData.settings) {
                        showDesign(false, designData);
                    } else {
                        throw new Error("D·ªØ li·ªáu JSON kh√¥ng h·ª£p l·ªá.");
                    }
                } catch (error) {
                    alert("‚ùå L·ªói khi t·∫£i file thi·∫øt k·∫ø. Vui l√≤ng ƒë·∫£m b·∫£o ƒë√¢y l√† file JSON h·ª£p l·ªá.");
                    console.error("L·ªói khi ƒë·ªçc file JSON:", error);
                }
            };
            reader.readAsText(file);
        }

        function loadDesignByIndex(index) {
            const savedDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
            if (savedDesigns[index]) {
                showDesign(false, savedDesigns[index]);
            } else {
                alert("Kh√¥ng t√¨m th·∫•y thi·∫øt k·∫ø n√†y.");
            }
        }

        function deleteDesignByIndex(index) {
             if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a thi·∫øt k·∫ø n√†y?")) {
                const savedDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
                savedDesigns.splice(index, 1); 
                localStorage.setItem('photoBoothDesigns', JSON.stringify(savedDesigns));
                loadDesigns(); 
                alert("Thi·∫øt k·∫ø ƒë√£ ƒë∆∞·ª£c x√≥a.");
            }
        }
        
        function exportFinalImage() {
            drawFrame(); 
            
            const imageURL = canvas.toDataURL("image/png");
            const link = document.createElement('a');
            link.download = `photobooth-strip-${currentDesignId || Date.now()}.png`;
            link.href = imageURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // ƒê√É C·∫¨P NH·∫¨T: H√†m Xu·∫•t Link Chia S·∫ª (Base64) - S·ª≠a l·ªói sao ch√©p
        function exportShareLink() {
            const designDataToShare = {
                id: currentDesignId || Math.random().toString(36).substring(2, 9),
                name: "Thi·∫øt K·∫ø ƒê∆∞·ª£c Chia S·∫ª",
                timestamp: Date.now(),
                settings: {
                    frameColor: frameColorInput.value,
                    frameThickness: frameThicknessInput.value,
                    photoSizeScale: photoSizeScaleInput.value,
                    stripWidth: stripWidthInput.value,
                    stripHeight: stripHeightInput.value,
                },
                photos: capturedPhotos.map(p => (p ? { src: p.src } : null)), 
                objects: canvasObjects.map(obj => {
                    if (obj.type !== 'text') {
                        const { image, ...rest } = obj;
                        return rest;
                    }
                    return obj;
                })
            };

            const jsonString = JSON.stringify(designDataToShare);
            const encodedDesign = btoa(unescape(encodeURIComponent(jsonString)));
            const shareLink = `${window.location.href.split('#')[0]}#${encodedDesign}`;
            
            // S·ª¨ D·ª§NG prompt ƒë·ªÉ d·ªÖ d√†ng sao ch√©p th·ªß c√¥ng v√† ƒë·∫£m b·∫£o link hi·ªán ƒë·∫ßy ƒë·ªß
            const promptResult = prompt(
                "‚úÖ Link Chia S·∫ª Thi·∫øt K·∫ø (ƒê√£ nh√∫ng to√†n b·ªô d·ªØ li·ªáu).\nVui l√≤ng B√îI ƒêEN to√†n b·ªô link v√† nh·∫•n Ctrl+C (ho·∫∑c Cmd+C) ƒë·ªÉ sao ch√©p:", 
                shareLink
            );

            if (promptResult === null) {
                alert("B·∫°n ƒë√£ h·ªßy thao t√°c sao ch√©p link.");
            }
        }
        
        // =======================================================
        // PH·∫¶N 5: G·∫ÆN S·ª∞ KI·ªÜN V√Ä KH·ªûI T·∫†O
        // =======================================================

        // G·∫Øn s·ª± ki·ªán T·∫£i ·∫¢nh
        addImageToStripBtn.addEventListener('click', () => {
            const file = imageUpload.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    handleImageAdd(e.target.result, file.name, 'image');
                };
                reader.readAsDataURL(file);
            } else {
                alert("Vui l√≤ng ch·ªçn m·ªôt file ·∫£nh ƒë·ªÉ t·∫£i l√™n.");
            }
        });
        
        // G·∫Øn s·ª± ki·ªán T·∫£i M·∫´u Thi·∫øt K·∫ø (JSON)
        designUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleDesignUpload(file);
            }
        });


        // G·∫Øn s·ª± ki·ªán T·∫£i Sticker T√πy Ch·ªânh
        addCustomStickerBtn.addEventListener('click', () => {
            const file = customStickerUpload.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    handleImageAdd(e.target.result, file.name, 'sticker');
                };
                reader.readAsDataURL(file);
            } else {
                alert("Vui l√≤ng ch·ªçn m·ªôt file sticker ƒë·ªÉ t·∫£i l√™n.");
            }
        });
        
        // G·∫Øn s·ª± ki·ªán T·∫£i Sticker C√≥ S·∫µn
        stickerLibrary.querySelectorAll('.predefined-sticker').forEach(button => {
            button.addEventListener('click', (e) => {
                const url = e.currentTarget.getAttribute('data-sticker-url');
                const name = e.currentTarget.textContent.trim();
                handleImageAdd(url, name, 'sticker');
            });
        });
        
        // G·∫Øn s·ª± ki·ªán Th√™m Text
        addTextToStripBtn.addEventListener('click', handleTextAdd);

        // G·∫Øn s·ª± ki·ªán Ch·ª•p ·∫£nh
        capturePhotoBtn.addEventListener('click', capturePhoto);

        // G·∫Øn s·ª± ki·ªán L∆∞u/Xu·∫•t
        saveDesignBtn.addEventListener('click', saveDesign);
        exportFinalImageBtn.addEventListener('click', exportFinalImage);
        exportShareLinkBtn.addEventListener('click', exportShareLink);
        
        // G·∫Øn s·ª± ki·ªán ƒêi·ªÅu ch·ªânh L·ªõp
        bringForwardBtn.addEventListener('click', () => adjustLayer('up'));
        sendBackwardBtn.addEventListener('click', () => adjustLayer('down'));
        bringToFrontBtn.addEventListener('click', () => adjustLayer('front'));
        sendToBackBtn.addEventListener('click', () => adjustLayer('back'));


        // G·∫Øn s·ª± ki·ªán cho c√°c ƒëi·ªÅu khi·ªÉn
        frameColorInput.addEventListener('input', drawFrame);
        frameThicknessInput.addEventListener('input', drawFrame);
        photoSizeScaleInput.addEventListener('input', drawFrame);
        stripWidthInput.addEventListener('change', drawFrame);
        stripHeightInput.addEventListener('change', drawFrame);
        fontSizeInput.addEventListener('input', () => {
             fontSizeValueSpan.textContent = `${fontSizeInput.value}px`;
             drawFrame(); 
        });
        fontSelect.addEventListener('change', drawFrame); 
        
        // G·∫Øn s·ª± ki·ªán K√©o/Th·∫£/Resize/Rotate
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseout', handleMouseUp); 


        // LOGIC T·∫¢I THI·∫æT K·∫æ T·ª™ BASE64/URL HASH (ƒê√É C·∫¨P NH·∫¨T VIEWER MODE)
        window.onload = () => {
            const hashValue = window.location.hash.substring(1);

            if (hashValue) {
                try {
                    // 1. C·ªê G·∫ÆNG GI·∫¢I M√É CHU·ªñI BASE64
                    const decodedJsonString = decodeURIComponent(escape(atob(hashValue)));
                    const designData = JSON.parse(decodedJsonString);
                    
                    if (designData && designData.settings) {
                        // T·∫£i m·∫´u th√†nh c√¥ng -> B·∫≠t ch·∫ø ƒë·ªô Viewer Mode
                        showDesign(false, designData);
                        toggleDesignerControls(false); // <--- T·∫ÆT CONTROLS CH·ªàNH S·ª¨A
                        return;
                    }

                } catch (e) {
                    // 3. N·∫øu gi·∫£i m√£ th·∫•t b·∫°i, th·ª≠ ki·ªÉm tra Local Storage (cho link ID c≈©)
                    const allDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
                    const sharedDesign = allDesigns.find(d => d.id === hashValue);
                    if (sharedDesign) {
                        showDesign(false, sharedDesign);
                        toggleDesignerControls(false); // <--- T·∫ÆT CONTROLS CH·ªàNH S·ª¨A
                        return;
                    }
                    console.error("L·ªói khi t·∫£i ho·∫∑c gi·∫£i m√£ link chia s·∫ª:", e);
                }
            }
            
            // 4. M·∫∑c ƒë·ªãnh: Hi·ªÉn th·ªã th∆∞ vi·ªán/Designer Mode
            showLibrary();
            toggleDesignerControls(true); // <--- B·∫¨T CONTROLS CH·ªàNH S·ª¨A
        };
    </script>
</body>
</html>