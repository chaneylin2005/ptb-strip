<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth Strip Designer T√πy Ch·ªânh (Phi√™n b·∫£n ƒê·∫ßy ƒë·ªß - C√≥ Google Fonts)</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Montserrat:ital,wght@0,400;0,700;1,400&family=Pacifico&family=Pinyon+Script&display=swap" rel="stylesheet">
    
    <style>
        /* ==================== CSS CHUNG ==================== */
        body { font-family: 'Montserrat', sans-serif; margin: 0; padding: 0; background-color: #f4f4f9; color: #333; }
        header { background-color: #007bff; color: white; padding: 20px; text-align: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        button, .primary-action, .secondary-action { border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; width: 100%; margin-top: 5px; }
        .primary-action { background-color: #28a745; color: white; font-size: 1.1em; margin-top: 20px; }
        .primary-action:hover { background-color: #1e7e34; }
        .secondary-action { background-color: #6c757d; color: white; }
        .secondary-action:hover { background-color: #5a6268; }
        .alert-message { background-color: #fff3cd; color: #856404; padding: 10px; border: 1px solid #ffeeba; border-radius: 4px; margin-bottom: 20px; text-align: center; }

        /* ==================== CH·∫æ ƒê·ªò THI·∫æT K·∫æ (DESIGN MODE) ==================== */
        #design-view { display: flex; max-width: 1200px; margin: 20px auto; padding: 0 15px; }
        .design-area { flex: 2; padding-right: 30px; text-align: center; }
        #photoStripCanvas { border: 5px dashed #ccc; background-color: white; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); max-width: 100%; height: auto; display: block; margin: 20px auto; cursor: grab; }
        .webcam-preview { margin-top: 20px; }
        #webcamFeed { width: 300px; height: auto; border: 2px solid #333; display: block; margin: 10px auto; }
        .controls-panel { flex: 1; background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        .control-group { border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 4px; }
        legend { font-weight: bold; color: #007bff; padding: 0 10px; }
        .control-group > div { margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; }
        .control-group > div:not(:last-child) { margin-bottom: 10px; }
        
        /* Input styling */
        input[type="range"] { flex-grow: 1; margin-left: 10px; }
        .control-group label { display: block; margin-bottom: 5px; }
        .control-group input[type="text"], 
        .control-group input[type="number"],
        .control-group input[type="color"], 
        .control-group select { flex-grow: 1; margin-left: 10px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .control-group input[type="color"] { width: 40px; height: 30px; padding: 0; }
        
        /* Specific elements */
        #capturePhotoBtn { background-color: #ffc107; color: #333; }
        #capturePhotoBtn:hover { background-color: #e0a800; }
        #stickerLibrary { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; margin-bottom: 15px; }
        .predefined-sticker { width: 40px; height: 40px; background-color: #eee; font-size: 1.2em; padding: 0; }
        #newDesignBtnDesign { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        #newDesignBtnDesign:hover { background-color: #0056b3; }
        
        /* Font Previews (cho select) */
        .font-arial { font-family: Arial, sans-serif; }
        .font-dancing { font-family: 'Dancing Script', cursive; }
        .font-pacifico { font-family: 'Pacifico', cursive; }
        .font-pinyon { font-family: 'Pinyon Script', cursive; }
        .font-montserrat { font-family: 'Montserrat', sans-serif; }


        /* ==================== CH·∫æ ƒê·ªò TH∆Ø VI·ªÜN (LIBRARY MODE) ==================== */
        #library-view { display: none; padding: 20px; text-align: center; }
        .design-list { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-top: 30px; }
        .design-card { background-color: white; border: 1px solid #ddd; border-radius: 8px; padding: 15px; width: 280px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05); }
        .design-card h3 { color: #007bff; margin-top: 0; }
        .design-card p { font-size: 0.9em; color: #666; }
        .action-group button { margin-top: 10px; padding: 8px 15px; width: 48%; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; }
        .load-btn { background-color: #28a745; color: white; }
        .delete-btn { background-color: #dc3545; color: white; margin-left: 5px; }
        #newDesignBtnLib { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 20px; }
        #newDesignBtnLib:hover { background-color: #0056b3; }
        
        /* Responsive */
        @media (max-width: 768px) {
            #design-view { flex-direction: column; }
            .design-area { padding-right: 0; padding-bottom: 20px; }
            .design-area > div { display: flex; flex-direction: row; gap: 10px; }
            .design-area button { flex-grow: 1; }
        }
    </style>
</head>
<body>

    <header>
        <h1 id="main-title">T·∫°o Strip Photo Booth C√° Nh√¢n</h1>
    </header>

    <div id="design-view">
        <section class="design-area">
            <div id="designer-actions-top" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button id="toggleViewBtn" class="secondary-action" style="width: auto;" onclick="showLibrary()">
                    ‚Üê Quay l·∫°i Th∆∞ Vi·ªán Thi·∫øt K·∫ø
                </button>
                <button id="newDesignBtnDesign" class="secondary-action" style="width: auto; flex-grow: 1; background-color: #007bff;" onclick="showDesign(true)">
                    **+ T·∫°o Thi·∫øt K·∫ø M·ªõi**
                </button>
            </div>
            <h2 id="canvas-header">Khung Xem Tr∆∞·ªõc Strip 4 ·∫¢nh (B·∫•m chu·ªôt ph·∫£i ƒë·ªÉ X√≥a ƒë·ªëi t∆∞·ª£ng)</h2>
            <canvas id="photoStripCanvas" width="600" height="1800">
                Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ Canvas.
            </canvas>
            <div class="webcam-preview">
                <video id="webcamFeed" autoplay></video>
                <button id="capturePhotoBtn">Ch·ª•p ·∫¢nh (1/4)</button>
                
                <label for="viewerImageUpload" id="viewerImageUploadLabel" class="secondary-action" style="display: none; text-align: center; margin-bottom: 5px; background-color: #17a2b8; color: white; ">
                    **Ho·∫∑c T·∫£i ·∫¢nh L√™n ƒê·ªÉ Thay Th·∫ø**
                </label>
                <input type="file" id="viewerImageUpload" accept="image/*"> 
            </div>
        </section>

        <aside id="controls-panel" class="controls-panel">
            <h2>üõ†Ô∏è C√¥ng C·ª• Thi·∫øt K·∫ø</h2>

            <fieldset class="control-group">
                <legend>T√πy Ch·ªânh C∆° B·∫£n</legend>
                <div><label for="frameColor">M√†u Khung/Vi·ªÅn:</label><input type="color" id="frameColor" value="#000000"></div>
                <div><label for="frameThickness">ƒê·ªô D√†y Khung (px):</label><input type="range" id="frameThickness" min="5" max="100" value="25"><span id="thicknessValue">25px</span></div>
                <div><label for="photoSizeScale">T·ª∑ L·ªá K√≠ch C·ª° ·∫¢nh:</label><input type="range" id="photoSizeScale" min="0.5" max="1.5" step="0.05" value="1.0"><span id="sizeValue">100%</span></div>
                <div><label for="stripWidth">ƒê·ªô R·ªông Strip (px):</label><input type="number" id="stripWidth" value="600" min="100"></div>
                <div><label for="stripHeight">ƒê·ªô D√†i Strip (px):</label><input type="number" id="stripHeight" value="1800" min="300"></div>
            </fieldset>

            <fieldset class="control-group">
                <legend>T·∫£i L√™n ·∫¢nh C√° Nh√¢n/Idol</legend>
                <div><input type="file" id="imageUpload" accept="image/*" style="width: 60%;"><button id="addImageToStripBtn" style="width: 40%; margin-top: 0;">Th√™m ·∫¢nh</button></div>
            </fieldset>
            
            <fieldset class="control-group">
                <legend>Th√™m Ch·ªØ / Ch·ªØ K√Ω</legend>
                <div><label for="textInput">VƒÉn b·∫£n:</label><input type="text" id="textInput" placeholder="Nh·∫≠p ch·ªØ/ch·ªØ k√Ω"></div>
                <div>
                    <label for="fontSelect">Font:</label>
                    <select id="fontSelect">
                        <option value="Montserrat" class="font-montserrat">Montserrat (Hi·ªán ƒë·∫°i)</option>
                        <option value="Arial" class="font-arial">Arial (C∆° b·∫£n)</option>
                        <option value="Dancing Script" class="font-dancing">Dancing Script (Vi·∫øt tay)</option>
                        <option value="Pacifico" class="font-pacifico">Pacifico (C·ªï ƒëi·ªÉn)</option>
                        <option value="Pinyon Script" class="font-pinyon">Pinyon Script (Ngh·ªá thu·∫≠t)</option>
                    </select>
                </div>
                <div><label for="textColor">M√†u ch·ªØ:</label><input type="color" id="textColor" value="#000000"></div>
                <div><label for="fontSize">K√≠ch th∆∞·ªõc:</label><input type="range" id="fontSize" min="10" max="100" value="40"><span id="fontSizeValue">40px</span></div>
                <button id="addTextToStripBtn">Th√™m Ch·ªØ</button>
            </fieldset>

            <fieldset class="control-group">
                <legend>Th∆∞ Vi·ªán Sticker</legend>
                <div id="stickerLibrary">
                    <button class="predefined-sticker" data-sticker-url="https://raw.githubusercontent.com/google/material-design-icons/master/png/social/star_black/1x_web/baseline_star_black_24dp.png">‚≠ê</button>
                    <button class="predefined-sticker" data-sticker-url="https://www.freeiconspng.com/uploads/red-heart-png-27.png">üíñ</button>
                    <button class="predefined-sticker" data-sticker-url="https://cdn-icons-png.flaticon.com/512/32/32185.png">üß¢</button>
                    <button class="predefined-sticker" data-sticker-url="https://www.freeiconspng.com/uploads/glasses-png-22.png">üï∂Ô∏è</button>
                </div>
                <div><label>T·∫£i Th√™m Sticker M·ªõi (.png/jpg):</label><input type="file" id="customStickerUpload" accept="image/*" style="width: 60%;"><button id="addCustomStickerBtn" style="width: 40%; margin-top: 0;">Th√™m Sticker</button></div>
            </fieldset>
            
            <fieldset class="control-group">
                <legend>ƒêi·ªÅu Ch·ªânh L·ªõp (Layer)</legend>
                <div>
                    <button id="bringForwardBtn" class="secondary-action" style="width: 49%; background-color: #ffc107; color: #333; margin-top: 0;">L√™n m·ªôt l·ªõp (‚¨Ü)</button>
                    <button id="sendBackwardBtn" class="secondary-action" style="width: 49%; background-color: #17a2b8; margin-top: 0;">Xu·ªëng m·ªôt l·ªõp (‚¨á)</button>
                </div>
                <div>
                    <button id="bringToFrontBtn" class="primary-action" style="width: 49%; margin-top: 5px;">L√™n tr√™n c√πng (‚è´)</button>
                    <button id="sendToBackBtn" class="secondary-action" style="width: 49%; background-color: #dc3545; margin-top: 5px;">Xu·ªëng d∆∞·ªõi c√πng (‚è¨)</button>
                </div>
                <div class="alert-message" id="layerControlAlert" style="display: none; margin-top: 10px; margin-bottom: 0;">
                    Vui l√≤ng ch·ªçn m·ªôt ƒë·ªëi t∆∞·ª£ng (·∫£nh, sticker, ch·ªØ) tr√™n canvas.
                </div>
            </fieldset>
            <fieldset class="control-group">
                <legend>L∆∞u v√† Chia S·∫ª M·∫´u</legend>
                
                <label for="designUpload" class="secondary-action" style="display: block; text-align: center; margin-bottom: 10px; background-color: #6c757d; color: white;">
                    **T·∫£i M·∫´u Thi·∫øt K·∫ø (File .json)**
                </label>
                <input type="file" id="designUpload" accept=".json" style="display: none;">
                
                <button id="saveDesignBtn" class="primary-action" style="background-color: #007bff;">L∆∞u Thi·∫øt K·∫ø & T·∫£i File .json</button>
                <button id="exportShareLinkBtn" class="secondary-action">Xu·∫•t Link Chia S·∫ª (ƒê√£ nh√∫ng d·ªØ li·ªáu)</button>
            </fieldset>

            <button id="exportFinalImageBtn" class="primary-action">Xu·∫•t Strip ·∫¢nh Ho√†n Ch·ªânh (T·∫£i v·ªÅ)</button>
        </aside>
    </div>

    <div id="library-view">
        <h1>üìö Th∆∞ Vi·ªán M·∫´u Thi·∫øt K·∫ø C·ªßa T√¥i</h1>
        <div class="alert-message">
            **L∆ØU √ù:** B·∫°n c√≥ th·ªÉ chia s·∫ª m·∫´u thi·∫øt k·∫ø b·∫±ng **Link Chia S·∫ª** (y√™u c·∫ßu host web nh∆∞ GitHub Pages) ho·∫∑c chia s·∫ª file **.json** (c√≥ th·ªÉ d√πng c·ª•c b·ªô).
        </div>
        <button id="newDesignBtnLib" onclick="showDesign(true)">+ T·∫°o M·∫´u Thi·∫øt K·∫ø M·ªõi</button>
        <div id="designList" class="design-list">
            <p>ƒêang t·∫£i th∆∞ vi·ªán...</p>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 Photo Booth Designer C·ªßa B·∫°n</p>
    </footer>

    <script>
        // Khai b√°o c√°c bi·∫øn DOM v√† h·∫±ng s·ªë
        const designView = document.getElementById('design-view');
        const libraryView = document.getElementById('library-view');
        const mainTitle = document.getElementById('main-title');

        const canvas = document.getElementById('photoStripCanvas');
        const ctx = canvas.getContext('2d');
        const webcamFeed = document.getElementById('webcamFeed');
        const capturePhotoBtn = document.getElementById('capturePhotoBtn');
        const exportFinalImageBtn = document.getElementById('exportFinalImageBtn');
        const frameColorInput = document.getElementById('frameColor');
        const frameThicknessInput = document.getElementById('frameThickness');
        const thicknessValueSpan = document.getElementById('thicknessValue');
        const photoSizeScaleInput = document.getElementById('photoSizeScale');
        const sizeValueSpan = document.getElementById('sizeValue');
        const stripWidthInput = document.getElementById('stripWidth');
        const stripHeightInput = document.getElementById('stripHeight');
        
        const imageUpload = document.getElementById('imageUpload');
        const addImageToStripBtn = document.getElementById('addImageToStripBtn');
        const stickerLibrary = document.getElementById('stickerLibrary');
        const customStickerUpload = document.getElementById('customStickerUpload');
        const addCustomStickerBtn = document.getElementById('addCustomStickerBtn');
        
        const designList = document.getElementById('designList');

        // Text Controls
        const textInput = document.getElementById('textInput');
        const fontSelect = document.getElementById('fontSelect');
        const textColorInput = document.getElementById('textColor');
        const fontSizeInput = document.getElementById('fontSize');
        const fontSizeValueSpan = document.getElementById('fontSizeValue');
        const addTextToStripBtn = document.getElementById('addTextToStripBtn');
        const saveDesignBtn = document.getElementById('saveDesignBtn');
        const exportShareLinkBtn = document.getElementById('exportShareLinkBtn');
        
        // Design File Upload
        const designUpload = document.getElementById('designUpload');
        
        // Layer Controls
        const bringForwardBtn = document.getElementById('bringForwardBtn');
        const sendBackwardBtn = document.getElementById('sendBackwardBtn');
        const bringToFrontBtn = document.getElementById('bringToFrontBtn');
        const sendToBackBtn = document.getElementById('sendToBackBtn');
        const layerControlAlert = document.getElementById('layerControlAlert');
        
        // C√ÅC PH·∫¶N T·ª¨ CHO VIEWER MODE
        const controlsPanel = document.getElementById('controls-panel');
        const designerActionsTop = document.getElementById('designer-actions-top');
        const toggleViewBtn = document.getElementById('toggleViewBtn');
        const canvasHeader = document.getElementById('canvas-header');
        const viewerImageUpload = document.getElementById('viewerImageUpload');
        const viewerImageUploadLabel = document.getElementById('viewerImageUploadLabel'); // N√∫t T·∫£i ·∫£nh cho Viewer Mode

        const MAX_PHOTOS = 4;

        let capturedPhotos = []; 
        let currentPhotoIndex = 0;
        let canvasObjects = []; 

        let isDragging = false;
        let isResizing = false;
        let isRotating = false; 
        let selectedObject = null;
        let startX;
        let startY;
        let lastAngle = 0; 
        let currentDesignId = null;

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i hi·ªÉn th·ªã c·ªßa n√∫t Layer Control
        function updateLayerControls() {
            if (selectedObject) {
                layerControlAlert.style.display = 'none';
                bringForwardBtn.disabled = false;
                sendBackwardBtn.disabled = false;
                bringToFrontBtn.disabled = false;
                sendToBackBtn.disabled = false;
            } else {
                layerControlAlert.style.display = 'block';
                bringForwardBtn.disabled = true;
                sendBackwardBtn.disabled = true;
                bringToFrontBtn.disabled = true;
                sendToBackBtn.disabled = true;
            }
        }


        canvas.addEventListener('contextmenu', (e) => {
            // Ch·ªâ cho ph√©p x√≥a khi ƒëang ·ªü Designer Mode
            if (controlsPanel.style.display === 'none') return;
            
            e.preventDefault(); 
            if (selectedObject) {
                 if (confirm("B·∫°n c√≥ mu·ªën x√≥a ƒë·ªëi t∆∞·ª£ng ƒë√£ ch·ªçn n√†y kh√¥ng?")) {
                    canvasObjects = canvasObjects.filter(obj => obj !== selectedObject);
                    selectedObject = null;
                    drawFrame();
                    updateLayerControls();
                 }
            }
        });

        // =======================================================
        // C√ÅC H√ÄM QU·∫¢N L√ù VIEW (SHOW DESIGN/LIBRARY)
        // =======================================================
        
        function toggleDesignerControls(show) {
            controlsPanel.style.display = show ? 'block' : 'none';
            designerActionsTop.style.display = show ? 'flex' : 'none';
            toggleViewBtn.style.display = show ? 'block' : 'none';
            
            // C·∫≠p nh·∫≠t giao di·ªán Viewer/Designer
            if (show) {
                mainTitle.textContent = "T·∫°o Strip Photo Booth C√° Nh√¢n";
                canvasHeader.textContent = "Khung Xem Tr∆∞·ªõc Strip 4 ·∫¢nh (B·∫•m chu·ªôt ph·∫£i ƒë·ªÉ X√≥a ƒë·ªëi t∆∞·ª£ng)";
                viewerImageUploadLabel.style.display = 'none';
                viewerImageUpload.style.display = 'none';
                exportFinalImageBtn.textContent = "Xu·∫•t Strip ·∫¢nh Ho√†n Ch·ªânh (T·∫£i v·ªÅ)";
                updateLayerControls();
            } else {
                mainTitle.textContent = "Xem & Ch·ª•p ·∫¢nh (Viewer Mode)";
                canvasHeader.textContent = "Khung ·∫¢nh ƒê√£ Thi·∫øt K·∫ø";
                viewerImageUploadLabel.style.display = 'block';
                viewerImageUpload.style.display = 'block';
                exportFinalImageBtn.textContent = "T·∫£i Strip ·∫¢nh ƒê√£ Ch·ª•p (4/4)";
                selectedObject = null; // B·ªè ch·ªçn ƒë·ªëi t∆∞·ª£ng khi chuy·ªÉn sang Viewer Mode
            }
        }
        
        function showDesign(isNew = false, designData = null) {
            designView.style.display = 'flex';
            libraryView.style.display = 'none';
            currentDesignId = null; 
            selectedObject = null;
            
            // M·∫∑c ƒë·ªãnh l√† Designer Mode, s·∫Ω b·ªã ghi ƒë√® n·∫øu load t·ª´ Hash (Viewer Mode)
            toggleDesignerControls(true); 

            if (isNew) {
                capturedPhotos = [];
                currentPhotoIndex = 0;
                canvasObjects = [];
                frameColorInput.value = '#000000';
                frameThicknessInput.value = '25';
                photoSizeScaleInput.value = '1.0';
                stripWidthInput.value = '600';
                stripHeightInput.value = '1800';
                
                currentDesignId = Math.random().toString(36).substring(2, 9);
            }

            if (designData) {
                currentDesignId = designData.id || Math.random().toString(36).substring(2, 9);
                frameColorInput.value = designData.settings.frameColor || '#000000';
                frameThicknessInput.value = designData.settings.frameThickness || '25';
                photoSizeScaleInput.value = designData.settings.photoSizeScale || '1.0';
                stripWidthInput.value = designData.settings.stripWidth || '600';
                stripHeightInput.value = designData.settings.stripHeight || '1800';
                
                capturedPhotos = [];
                currentPhotoIndex = 0;
                if (designData.photos && designData.photos.length) {
                    designData.photos.forEach((photoData, index) => {
                        if (photoData && photoData.src) {
                            const img = new Image();
                            img.onload = () => {
                                capturedPhotos[index] = { index: index, image: img, src: photoData.src };
                                currentPhotoIndex = Math.max(currentPhotoIndex, index + 1);
                                updateCaptureButtonText();
                                drawFrame();
                            };
                            img.crossOrigin = "Anonymous";
                            img.src = photoData.src;
                        }
                    });
                }
                
                canvasObjects = [];
                let loadCount = 0;
                const totalObjects = designData.objects.length;
                
                const finishLoading = () => {
                    loadCount++;
                    if (loadCount === totalObjects || totalObjects === 0) {
                        drawFrame();
                        // Ch·ªâ hi·ªán th√¥ng b√°o khi t·∫£i t·ª´ Local Storage/File V√Ä ƒëang ·ªü ch·∫ø ƒë·ªô Designer
                        if (controlsPanel.style.display !== 'none') {
                            alert(`Thi·∫øt k·∫ø "${designData.name || currentDesignId}" ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng!`);
                        }
                    }
                };

                designData.objects.forEach(objData => {
                    if (objData.type === 'text') {
                        canvasObjects.push(objData);
                        finishLoading();
                    } else if (objData.src) {
                        const img = new Image();
                        img.onload = () => {
                            canvasObjects.push({...objData, image: img});
                            finishLoading();
                        };
                        img.onerror = finishLoading; 
                        img.crossOrigin = "Anonymous"; 
                        img.src = objData.src;
                    } else {
                        finishLoading(); // B·ªè qua ƒë·ªëi t∆∞·ª£ng kh√¥ng c√≥ src (v√≠ d·ª•: b·ªã l·ªói)
                    }
                });
            }

            drawFrame();
            updateCaptureButtonText();
            updateLayerControls();
            if (!webcamFeed.srcObject || !webcamFeed.srcObject.active) {
                startWebcam();
            }
        }
        
        function showLibrary() {
            designView.style.display = 'none';
            libraryView.style.display = 'block'; 
            
            toggleDesignerControls(true); // B·∫ÆT BU·ªòC B·∫¨T DESIGNER MODE KHI V√ÄO TH∆Ø VI·ªÜN
            loadDesigns(); 
            
            if (webcamFeed.srcObject) {
                webcamFeed.srcObject.getTracks().forEach(track => track.stop());
                webcamFeed.srcObject = null;
            }
        }

        function loadDesignByIndex(index) {
            const savedDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
            if (savedDesigns[index]) {
                showDesign(false, savedDesigns[index]);
                toggleDesignerControls(true); // B·∫ÆT BU·ªòC B·∫¨T DESIGNER MODE KHI T·∫¢I T·ª™ TH∆Ø VI·ªÜN
            } else {
                alert("Kh√¥ng t√¨m th·∫•y thi·∫øt k·∫ø n√†y.");
            }
        }


        // =======================================================
        // PH·∫¶N 1: KH·ªûI T·∫†O V√Ä V·∫º CANVAS (T·ª™ CODE C≈®)
        // =======================================================

        async function startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                webcamFeed.srcObject = stream;
                webcamFeed.style.display = 'block';
                capturePhotoBtn.style.display = 'block';
            } catch (error) {
                console.error("Kh√¥ng th·ªÉ truy c·∫≠p webcam:", error);
                webcamFeed.style.display = 'none';
                alert("Kh√¥ng th·ªÉ truy c·∫≠p Webcam. Vui l√≤ng s·ª≠ d·ª•ng t√≠nh nƒÉng 'T·∫£i ·∫¢nh L√™n ƒê·ªÉ Thay Th·∫ø'.");
            }
        }

        function updateCaptureButtonText() {
            if (currentPhotoIndex < MAX_PHOTOS) {
                capturePhotoBtn.textContent = `Ch·ª•p ·∫¢nh (${currentPhotoIndex + 1}/${MAX_PHOTOS})`;
                capturePhotoBtn.disabled = false;
            } else {
                capturePhotoBtn.textContent = `HO√ÄN T·∫§T CH·ª§P! (S·∫µn s√†ng Xu·∫•t ·∫¢nh)`;
                capturePhotoBtn.disabled = true;
            }
        }
        
        function capturePhoto() {
            if (currentPhotoIndex >= MAX_PHOTOS) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = webcamFeed.videoWidth;
            tempCanvas.height = webcamFeed.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(webcamFeed, 0, 0, tempCanvas.width, tempCanvas.height);

            const capturedImage = new Image();
            capturedImage.onload = () => {
                capturedPhotos[currentPhotoIndex] = {
                    index: currentPhotoIndex,
                    image: capturedImage,
                    src: tempCanvas.toDataURL('image/png') 
                };
                currentPhotoIndex++;
                updateCaptureButtonText();
                drawFrame(); 
            };
            capturedImage.src = tempCanvas.toDataURL('image/png');
        }


        function drawFrame() {
            const scale = parseFloat(photoSizeScaleInput.value);
            const thickness = parseInt(frameThicknessInput.value);
            
            let currentWidth = parseFloat(stripWidthInput.value);
            let currentHeight = parseFloat(stripHeightInput.value);

            currentWidth = Math.max(100, currentWidth);
            currentHeight = Math.max(300, currentHeight);
            stripWidthInput.value = currentWidth.toFixed(0);
            stripHeightInput.value = currentHeight.toFixed(0);

            canvas.width = currentWidth;
            canvas.height = currentHeight;
            thicknessValueSpan.textContent = `${thickness}px`;
            sizeValueSpan.textContent = `${(scale * 100).toFixed(0)}%`;
            fontSizeValueSpan.textContent = `${fontSizeInput.value}px`; 


            ctx.clearRect(0, 0, currentWidth, currentHeight);
            ctx.fillStyle = frameColorInput.value;
            ctx.fillRect(0, 0, currentWidth, currentHeight);

            const photoWidth = currentWidth - 2 * thickness;
            const photoHeight = (currentHeight - (MAX_PHOTOS + 1) * thickness) / MAX_PHOTOS; 

            if (photoWidth <= 0 || photoHeight <= 0) {
                ctx.fillStyle = 'red';
                ctx.font = '30px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('K√≠ch th∆∞·ªõc khung qu√° l·ªõn!', currentWidth / 2, currentHeight / 2);
                return;
            }

            for (let i = 0; i < MAX_PHOTOS; i++) {
                const x = thickness;
                const y = thickness + i * (photoHeight + thickness); 

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y, photoWidth, photoHeight);

                if (capturedPhotos[i] && capturedPhotos[i].image) {
                    const img = capturedPhotos[i].image;
                    const imgW = img.width;
                    const imgH = img.height;
                    const hRatio = photoWidth / imgW;
                    const vRatio = photoHeight / imgH;
                    const ratio = Math.max(hRatio, vRatio); 
                    
                    const drawW = imgW * ratio * scale; // √Åp d·ª•ng scale
                    const drawH = imgH * ratio * scale; // √Åp d·ª•ng scale
                    const drawX = x + (photoWidth - drawW) / 2;
                    const drawY = y + (photoHeight - drawH) / 2;
                    
                    ctx.drawImage(img, drawX, drawY, drawW, drawH);
                } else {
                    ctx.fillStyle = 'gray';
                    ctx.font = '30px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`·∫¢nh ${i + 1} CH∆ØA CH·ª§P`, x + photoWidth / 2, y + photoHeight / 2);
                }
            }
            
            // V·∫º C√ÅC STICKER/·∫¢NH/TEXT T·∫£i l√™n
            canvasObjects.forEach(obj => {
                ctx.save();
                
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                ctx.translate(centerX, centerY);
                ctx.rotate(obj.angle || 0); 
                ctx.translate(-centerX, -centerY); 

                if (obj.type === 'image' || obj.type === 'sticker') {
                    ctx.drawImage(obj.image, obj.x, obj.y, obj.width, obj.height);
                } else if (obj.type === 'text') {
                    // S·ª≠ d·ª•ng font Google
                    ctx.font = `${obj.fontSize}px "${obj.fontFamily}", sans-serif`;
                    ctx.fillStyle = obj.textColor;
                    ctx.textAlign = obj.textAlign;
                    ctx.textBaseline = obj.textBaseline;

                    const metrics = ctx.measureText(obj.text);
                    obj.width = metrics.width;
                    obj.height = obj.fontSize;
                    
                    ctx.fillText(obj.text, obj.x, obj.y + obj.fontSize * 0.75);
                }
                
                // V·∫Ω vi·ªÅn v√† ƒëi·ªÉm ƒëi·ªÅu khi·ªÉn ch·ªâ khi ·ªü Designer Mode V√Ä ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c ch·ªçn
                if (controlsPanel.style.display !== 'none' && obj === selectedObject) {
                    ctx.strokeStyle = '#FF00FF'; 
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                    
                    const controlPointSize = 10;
                    
                    // Resize Handle (Bottom-Right)
                    ctx.fillStyle = '#00FFFF';
                    ctx.fillRect(obj.x + obj.width - controlPointSize / 2, 
                                 obj.y + obj.height - controlPointSize / 2, 
                                 controlPointSize, controlPointSize);
                    
                    // Rotate Handle (Top-Left)
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(obj.x - controlPointSize / 2, 
                                 obj.y - controlPointSize / 2, 
                                 controlPointSize, controlPointSize);
                }
                ctx.restore(); 
            });
        }

        // =======================================================
        // PH·∫¶N 2: LOGIC TH√äM ·∫¢NH/STICKER/TEXT (T·ª™ CODE C≈®)
        // =======================================================

        function handleImageAdd(source, name, type, positionData = null) {
            const img = new Image();
            img.onload = () => {
                const defaultSize = 150; 
                let aspectRatio = 1;

                if (img.width > 0 && img.height > 0) {
                    aspectRatio = img.height / img.width;
                }

                let initialWidth = defaultSize;
                if (img.width > canvas.width) {
                    initialWidth = canvas.width / 4;
                    aspectRatio = img.height / img.width;
                }

                const newObject = {
                    name: name,
                    type: type, 
                    image: img,
                    src: source, 
                    x: positionData ? positionData.x : canvas.width / 2 - initialWidth / 2, 
                    y: positionData ? positionData.y : canvas.height / 2 - initialWidth / 2,
                    width: positionData ? positionData.width : initialWidth,
                    height: positionData ? positionData.height : initialWidth * aspectRatio,
                    angle: positionData ? positionData.angle : 0, 
                };
                
                canvasObjects.push(newObject);
                selectedObject = newObject; 
                drawFrame(); 
                updateLayerControls();
            };
            img.onerror = () => {
                console.error(`Kh√¥ng th·ªÉ t·∫£i ${type}: ${name}. Source: ${source}`);
                alert(`L·ªói: Kh√¥ng th·ªÉ t·∫£i ${type} "${name}". Vui l√≤ng ki·ªÉm tra file ho·∫∑c ƒë∆∞·ªùng d·∫´n.`);
            };
            
            if (source.startsWith('http') && !source.startsWith(window.location.origin)) {
                img.crossOrigin = "Anonymous";
            }
            img.src = source;
        }

        function handleTextAdd() {
            const text = textInput.value;
            const font = fontSelect.value;
            const color = textColorInput.value;
            const size = parseInt(fontSizeInput.value);

            if (!text.trim()) {
                alert("Vui l√≤ng nh·∫≠p vƒÉn b·∫£n ho·∫∑c ch·ªØ k√Ω.");
                return;
            }

            const newObject = {
                name: text,
                type: 'text',
                text: text,
                fontFamily: font,
                textColor: color,
                fontSize: size,
                x: canvas.width / 2, 
                y: canvas.height / 2,
                width: 0, 
                height: 0, 
                angle: 0,
                textAlign: 'center', 
                textBaseline: 'middle' 
            };
            canvasObjects.push(newObject);
            selectedObject = newObject; 
            drawFrame(); 
            updateLayerControls();
            textInput.value = '';
        }
        
        // =======================================================
        // PH·∫¶N 3: LOGIC K√âO, TH·∫¢, RESIZING, ROTATING & LAYER (T·ª™ CODE C≈®)
        // =======================================================

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }
        
        function isPointInObject(x, y, obj) {
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;

            const cos = Math.cos(-obj.angle);
            const sin = Math.sin(-obj.angle);
            
            const rotatedX = cos * (x - centerX) - sin * (y - centerY) + centerX;
            const rotatedY = sin * (x - centerX) + cos * (y - centerY) + centerY;

            return rotatedX >= obj.x && rotatedX <= obj.x + obj.width &&
                   rotatedY >= obj.y && rotatedY <= obj.y + obj.height;
        }
        
        function isPointInResizeHandle(x, y, obj) {
            const controlPointSize = 10;
            const handleX = obj.x + obj.width;
            const handleY = obj.y + obj.height;
            
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;

            const cos = Math.cos(obj.angle);
            const sin = Math.sin(obj.angle);

            const rotatedHandleX = cos * (handleX - centerX) - sin * (handleY - centerY) + centerX;
            const rotatedHandleY = sin * (handleX - centerX) + cos * (handleY - centerY) + centerY;

            return x >= rotatedHandleX - controlPointSize && x <= rotatedHandleX + controlPointSize &&
                   y >= rotatedHandleY - controlPointSize && y <= rotatedHandleY + controlPointSize;
        }

        function isPointInRotateHandle(x, y, obj) {
            const controlPointSize = 10;
            const handleX = obj.x;
            const handleY = obj.y;

            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;

            const cos = Math.cos(obj.angle);
            const sin = Math.sin(obj.angle);

            const rotatedHandleX = cos * (handleX - centerX) - sin * (handleY - centerY) + centerX;
            const rotatedHandleY = sin * (handleX - centerX) + cos * (handleY - centerY) + centerY;

            return x >= rotatedHandleX - controlPointSize && x <= rotatedHandleX + controlPointSize &&
                   y >= rotatedHandleY - controlPointSize && y <= rotatedHandleY + controlPointSize;
        }

        function handleMouseDown(e) {
            // Ch·ªâ cho ph√©p t∆∞∆°ng t√°c khi ·ªü Designer Mode
            if (controlsPanel.style.display === 'none') return;
            
            const mousePos = getMousePos(e);
            let foundObject = null;
            isResizing = false;
            isRotating = false;
            
            // X·ª≠ l√Ω ng∆∞·ª£c t·ª´ tr√™n xu·ªëng (layer tr√™n c√πng)
            for (let i = canvasObjects.length - 1; i >= 0; i--) {
                const obj = canvasObjects[i];
                
                // 1. Ki·ªÉm tra Resize/Rotate Handle (∆∞u ti√™n)
                if (selectedObject === obj && isPointInResizeHandle(mousePos.x, mousePos.y, obj)) {
                    isResizing = true;
                    selectedObject = obj;
                    startX = mousePos.x;
                    startY = mousePos.y;
                    return;
                }
                
                if (selectedObject === obj && isPointInRotateHandle(mousePos.x, mousePos.y, obj)) {
                    isRotating = true;
                    selectedObject = obj;
                    const dx = mousePos.x - (obj.x + obj.width / 2);
                    const dy = mousePos.y - (obj.y + obj.height / 2);
                    lastAngle = Math.atan2(dy, dx) - (obj.angle || 0);
                    return;
                }

                // 2. Ki·ªÉm tra Body c·ªßa Object
                if (isPointInObject(mousePos.x, mousePos.y, obj)) {
                    foundObject = obj;
                    break; 
                }
            }

            if (foundObject) {
                // ƒê·∫©y ƒë·ªëi t∆∞·ª£ng l√™n layer tr√™n c√πng n·∫øu n√≥ kh√¥ng ph·∫£i l√† ƒë·ªëi t∆∞·ª£ng tr√™n c√πng
                if (foundObject !== canvasObjects[canvasObjects.length - 1]) {
                     canvasObjects = canvasObjects.filter(obj => obj !== foundObject);
                     canvasObjects.push(foundObject);
                }
                selectedObject = foundObject;
                isDragging = true;
                startX = mousePos.x - selectedObject.x;
                startY = mousePos.y - selectedObject.y;
                drawFrame(); 
                updateLayerControls();
            } else {
                selectedObject = null;
                drawFrame();
                updateLayerControls();
            }
        }
        
        function handleMouseMove(e) {
            // Ch·ªâ cho ph√©p t∆∞∆°ng t√°c khi ·ªü Designer Mode
            if (controlsPanel.style.display === 'none') return;
            
            const mousePos = getMousePos(e);

            if (isDragging && selectedObject) {
                selectedObject.x = mousePos.x - startX;
                selectedObject.y = mousePos.y - startY;
                drawFrame();
            } else if (isResizing && selectedObject) {
                if (selectedObject.type !== 'text') {
                    const dx = mousePos.x - selectedObject.x;
                    const dy = mousePos.y - selectedObject.y;
                    
                    // T√≠nh chi·ªÅu d√†i m·ªõi t·ª´ g√≥c d∆∞·ªõi ph·∫£i (theo ph∆∞∆°ng ngang)
                    let newWidth = dx;
                    let newHeight;
                    
                    if (selectedObject.image) {
                        // Gi·ªØ t·ª∑ l·ªá khung h√¨nh
                        const aspectRatio = selectedObject.image.height / selectedObject.image.width;
                        newHeight = newWidth * aspectRatio;
                    } else {
                        // ƒêi·ªÅu ch·ªânh c·∫£ hai
                        newHeight = dy;
                    }

                    // ƒê·∫£m b·∫£o k√≠ch th∆∞·ªõc t·ªëi thi·ªÉu
                    if (newWidth > 20 && newHeight > 20) {
                        selectedObject.width = newWidth;
                        selectedObject.height = newHeight;
                    }
                }
                drawFrame();
            } else if (isRotating && selectedObject) {
                const centerX = selectedObject.x + selectedObject.width / 2;
                const centerY = selectedObject.y + selectedObject.height / 2;
                const dx = mousePos.x - centerX;
                const dy = mousePos.y - centerY;
                
                selectedObject.angle = Math.atan2(dy, dx) - lastAngle;
                drawFrame();
            }
        }

        function handleMouseUp() {
            isDragging = false;
            isResizing = false;
            isRotating = false;
            canvas.style.cursor = 'grab';
        }

        // =======================================================
        // PH·∫¶N 4: LOGIC QU·∫¢N L√ù THI·∫æT K·∫æ V√Ä EXPORT
        // =======================================================

        function getDesignData(designName = 'PhotoStrip') {
            const designNameClean = designName.replace(/[^a-z0-9]/gi, '_');
            return {
                id: currentDesignId,
                name: designNameClean,
                timestamp: new Date().toISOString(),
                settings: {
                    frameColor: frameColorInput.value,
                    frameThickness: frameThicknessInput.value,
                    photoSizeScale: photoSizeScaleInput.value,
                    stripWidth: stripWidthInput.value,
                    stripHeight: stripHeightInput.value,
                },
                photos: capturedPhotos.map(p => ({ src: p.src })), // Ch·ªâ l∆∞u DataURL
                objects: canvasObjects.map(obj => {
                    const data = {
                        type: obj.type,
                        x: obj.x,
                        y: obj.y,
                        width: obj.width,
                        height: obj.height,
                        angle: obj.angle,
                    };
                    if (obj.type === 'text') {
                        data.text = obj.text;
                        data.fontFamily = obj.fontFamily;
                        data.textColor = obj.textColor;
                        data.fontSize = obj.fontSize;
                        data.textAlign = obj.textAlign;
                        data.textBaseline = obj.textBaseline;
                    } else {
                        data.src = obj.src; // DataURL ho·∫∑c URL b√™n ngo√†i
                    }
                    return data;
                }),
            };
        }

        function saveDesignToLocalStorage() {
            const designName = prompt("Nh·∫≠p t√™n cho m·∫´u thi·∫øt k·∫ø n√†y:", currentDesignId || 'PhotoStrip_New');
            if (!designName) return;

            const designData = getDesignData(designName);
            designData.name = designName; // C·∫≠p nh·∫≠t t√™n sau khi ng∆∞·ªùi d√πng nh·∫≠p

            let savedDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
            const existingIndex = savedDesigns.findIndex(d => d.id === currentDesignId);

            if (existingIndex > -1) {
                savedDesigns[existingIndex] = designData;
            } else {
                savedDesigns.push(designData);
            }

            localStorage.setItem('photoBoothDesigns', JSON.stringify(savedDesigns));
            return designData;
        }
        
        function loadDesigns() {
            const savedDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
            designList.innerHTML = '';

            if (savedDesigns.length === 0) {
                designList.innerHTML = '<p>B·∫°n ch∆∞a c√≥ m·∫´u thi·∫øt k·∫ø n√†o. B·∫•m "+ T·∫°o M·∫´u Thi·∫øt K·∫ø M·ªõi" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>';
                return;
            }

            savedDesigns.forEach((design, index) => {
                const card = document.createElement('div');
                card.className = 'design-card';
                card.innerHTML = `
                    <h3>${design.name || design.id}</h3>
                    <p>C·∫≠p nh·∫≠t: ${new Date(design.timestamp).toLocaleDateString()}</p>
                    <div class="action-group">
                        <button class="load-btn" onclick="loadDesignByIndex(${index})">T·∫£i M·∫´u</button>
                        <button class="delete-btn" onclick="deleteDesign(${index})">X√≥a</button>
                    </div>
                `;
                designList.appendChild(card);
            });
        }
        
        function deleteDesign(index) {
            if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a m·∫´u thi·∫øt k·∫ø n√†y kh√¥ng?")) {
                let savedDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
                savedDesigns.splice(index, 1);
                localStorage.setItem('photoBoothDesigns', JSON.stringify(savedDesigns));
                loadDesigns();
            }
        }
        
        function exportDesignAsJson(designData) {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(designData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `${designData.name || designData.id}.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
        
        function handleDesignUpload(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const designData = JSON.parse(e.target.result);
                    if (designData && designData.settings) {
                        showDesign(false, designData);
                        toggleDesignerControls(true); // B·∫ÆT BU·ªòC B·∫¨T DESIGNER MODE KHI T·∫¢I T·ª™ FILE
                    } else {
                        alert("File JSON kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra c·∫•u tr√∫c file.");
                    }
                } catch (error) {
                    console.error("L·ªói khi ƒë·ªçc file JSON:", error);
                    alert("L·ªói: Kh√¥ng th·ªÉ ƒë·ªçc file JSON. Vui l√≤ng ƒë·∫£m b·∫£o file kh√¥ng b·ªã h·ªèng.");
                }
            };
            reader.readAsText(file);
        }
        
        function exportFinalImage() {
            if (currentPhotoIndex < MAX_PHOTOS) {
                if (!confirm(`B·∫°n m·ªõi ch·ªâ ch·ª•p ${currentPhotoIndex}/${MAX_PHOTOS} ·∫£nh. Ti·∫øp t·ª•c xu·∫•t ·∫£nh?`)) {
                    return;
                }
            }

            const dataURL = canvas.toDataURL('image/png');
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataURL);
            downloadAnchorNode.setAttribute("download", `photo_strip_${currentDesignId || 'final'}.png`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function exportShareLink() {
            const designData = getDesignData('Shareable');
            // X√≥a tr∆∞·ªùng image kh·ªèi objects ƒë·ªÉ gi·∫£m k√≠ch th∆∞·ªõc (ch·ªâ gi·ªØ l·∫°i src)
            designData.objects = designData.objects.map(obj => {
                const { image, ...rest } = obj;
                return rest;
            });
            
            const jsonString = JSON.stringify(designData);
            const base64Data = btoa(unescape(encodeURIComponent(jsonString)));
            const shareLink = `${window.location.origin}${window.location.pathname}#${base64Data}`;

            // L∆∞u link v√†o clipboard
            navigator.clipboard.writeText(shareLink).then(() => {
                alert(`ƒê√£ sao ch√©p link chia s·∫ª v√†o clipboard!\n\nLink: ${shareLink.substring(0, 100)}...`);
            }).catch(err => {
                console.error('Kh√¥ng th·ªÉ sao ch√©p link:', err);
                prompt("Sao ch√©p link chia s·∫ª th·ªß c√¥ng:", shareLink);
            });
        }

        // =======================================================
        // PH·∫¶N 5: X·ª¨ L√ù S·ª∞ KI·ªÜN V√Ä KH·ªûI T·∫†O
        // =======================================================
        
        // --- X·ª≠ l√Ω Layer Controls ---
        function moveLayer(direction) {
            if (!selectedObject) return;
            const currentIndex = canvasObjects.indexOf(selectedObject);
            let newIndex = currentIndex + direction;
            
            if (newIndex >= 0 && newIndex < canvasObjects.length) {
                canvasObjects.splice(currentIndex, 1); // X√≥a kh·ªèi v·ªã tr√≠ c≈©
                canvasObjects.splice(newIndex, 0, selectedObject); // Ch√®n v√†o v·ªã tr√≠ m·ªõi
                drawFrame();
            }
        }
        
        function moveLayerToExtreme(isFront) {
            if (!selectedObject) return;
            canvasObjects = canvasObjects.filter(obj => obj !== selectedObject);
            if (isFront) {
                canvasObjects.push(selectedObject);
            } else {
                canvasObjects.unshift(selectedObject);
            }
            drawFrame();
        }

        // --- G·∫Øn S·ª± ki·ªán ---
        capturePhotoBtn.addEventListener('click', capturePhoto);
        exportFinalImageBtn.addEventListener('click', exportFinalImage);
        frameColorInput.addEventListener('input', drawFrame);
        frameThicknessInput.addEventListener('input', drawFrame);
        photoSizeScaleInput.addEventListener('input', drawFrame);
        stripWidthInput.addEventListener('change', drawFrame);
        stripHeightInput.addEventListener('change', drawFrame);
        fontSizeInput.addEventListener('input', drawFrame);

        // --- ·∫¢nh/Sticker ---
        addImageToStripBtn.addEventListener('click', () => {
            if (imageUpload.files.length > 0) {
                handleImageAdd(URL.createObjectURL(imageUpload.files[0]), imageUpload.files[0].name, 'image');
            } else {
                alert("Vui l√≤ng ch·ªçn m·ªôt file ·∫£nh ƒë·ªÉ t·∫£i l√™n.");
            }
        });
        document.querySelectorAll('.predefined-sticker').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const url = e.target.getAttribute('data-sticker-url');
                handleImageAdd(url, 'sticker_' + e.target.textContent, 'sticker');
            });
        });
        addCustomStickerBtn.addEventListener('click', () => {
            if (customStickerUpload.files.length > 0) {
                handleImageAdd(URL.createObjectURL(customStickerUpload.files[0]), customStickerUpload.files[0].name, 'sticker');
            } else {
                alert("Vui l√≤ng ch·ªçn m·ªôt file sticker ƒë·ªÉ t·∫£i l√™n.");
            }
        });
        
        // --- Text ---
        addTextToStripBtn.addEventListener('click', handleTextAdd);
        textInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleTextAdd();
        });
        fontSelect.addEventListener('change', drawFrame);
        textColorInput.addEventListener('input', drawFrame);
        
        // --- L∆∞u/Chia s·∫ª ---
        saveDesignBtn.addEventListener('click', () => {
            const designData = saveDesignToLocalStorage();
            if (designData) {
                exportDesignAsJson(designData);
            }
        });
        exportShareLinkBtn.addEventListener('click', exportShareLink);
        designUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleDesignUpload(e.target.files[0]);
            }
        });
        
        // --- Layer Controls ---
        bringForwardBtn.addEventListener('click', () => moveLayer(1));
        sendBackwardBtn.addEventListener('click', () => moveLayer(-1));
        bringToFrontBtn.addEventListener('click', () => moveLayerToExtreme(true));
        sendToBackBtn.addEventListener('click', () => moveLayerToExtreme(false));
        
        // --- Viewer Image Upload ---
        viewerImageUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                if (currentPhotoIndex < MAX_PHOTOS) {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const capturedImage = new Image();
                        capturedImage.onload = () => {
                            capturedPhotos[currentPhotoIndex] = {
                                index: currentPhotoIndex,
                                image: capturedImage,
                                src: event.target.result 
                            };
                            currentPhotoIndex++;
                            updateCaptureButtonText();
                            drawFrame(); 
                        };
                        capturedImage.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                } else {
                    alert("ƒê√£ ƒë·ªß 4 ·∫£nh. Vui l√≤ng T·∫£i Strip ·∫¢nh Ho√†n Ch·ªânh ho·∫∑c t·∫°o m·∫´u m·ªõi.");
                }
            }
        });


        // --- Canvas Interaction ---
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp); // X·ª≠ l√Ω khi chu·ªôt r·ªùi kh·ªèi canvas

        // LOGIC T·∫¢I THI·∫æT K·∫æ T·ª™ BASE64/URL HASH (ƒê√É C·∫¨P NH·∫¨T)
        window.onload = () => {
            const hashValue = window.location.hash.substring(1);

            if (hashValue) {
                try {
                    // 1. C·ªê G·∫ÆNG GI·∫¢I M√É CHU·ªñI BASE64
                    const decodedJsonString = decodeURIComponent(escape(atob(hashValue)));
                    const designData = JSON.parse(decodedJsonString);
                    
                    if (designData && designData.settings) {
                        // T·∫£i m·∫´u th√†nh c√¥ng -> B·∫≠t ch·∫ø ƒë·ªô Viewer Mode V√Ä THO√ÅT
                        showDesign(false, designData);
                        toggleDesignerControls(false); // <--- T·∫ÆT CONTROLS CH·ªàNH S·ª¨A V√Ä ƒê·∫∂T VIEWER MODE
                        return; // NgƒÉn kh√¥ng cho ch·∫°y ti·∫øp xu·ªëng showLibrary
                    }

                } catch (e) {
                    // 2. N·∫øu gi·∫£i m√£ th·∫•t b·∫°i, in l·ªói v√† kh√¥ng l√†m g√¨ kh√°c
                    console.error("L·ªói khi t·∫£i ho·∫∑c gi·∫£i m√£ link chia s·∫ª:", e);
                    // D√ô C√ì L·ªñI, V·∫™N PH·∫¢I X√ìA HASH ƒë·ªÉ v√†o ch·∫ø ƒë·ªô b√¨nh th∆∞·ªùng
                    window.location.hash = ''; 
                }
            }
            
            // 3. M·∫∑c ƒë·ªãnh ho·∫∑c n·∫øu hash l·ªói: Hi·ªÉn th·ªã th∆∞ vi·ªán/Designer Mode
            showLibrary();
        };
    </script>
</body>
</html>