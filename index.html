<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth Strip Designer - AI Assistant</title>
    <style>
        /* CSS CƒÉn B·∫£n */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            width: 100%;
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            padding: 15px 0;
            text-align: center;
        }

        h1 {
            color: #4a4a4a;
            margin: 0;
            font-size: 1.5em;
        }

        .main-container {
            display: flex;
            width: 95%;
            max-width: 1400px;
            margin: 20px auto;
            gap: 20px;
            flex-grow: 1;
        }

        /* Giao di·ªán Th∆∞ vi·ªán */
        #library-view {
            display: none;
            width: 100%;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .library-actions {
            margin-bottom: 20px;
            text-align: right;
        }

        .design-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .design-card {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 6px;
            background-color: #fafafa;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .design-card h3 {
            margin-top: 0;
            color: #007bff;
        }

        .action-group button {
            padding: 8px 12px;
            margin-right: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .load-btn {
            background-color: #28a745;
            color: white;
        }

        .delete-btn {
            background-color: #dc3545;
            color: white;
        }

        /* Giao di·ªán Thi·∫øt k·∫ø */
        #design-view {
            display: flex;
            gap: 20px;
            width: 100%;
        }

        .controls-panel {
            width: 300px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: 80vh;
        }

        .canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e9ecef;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }

        canvas {
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            /* D√πng width/height c·ªë ƒë·ªãnh, sau n√†y JS s·∫Ω set l·∫°i */
            width: 300px;
            height: 900px;
            cursor: grab;
        }

        /* Input Styles */
        .control-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 4px;
        }

        .control-group h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #007bff;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        label {
            display: block;
            margin-top: 5px;
            font-weight: 600;
            font-size: 0.9em;
        }

        input[type="number"],
        input[type="color"],
        input[type="text"],
        input[type="file"],
        select {
            width: calc(100% - 10px);
            padding: 8px;
            margin-top: 3px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .button-group button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .button-group button:hover {
            opacity: 0.9;
        }

        #capturePhotoBtn {
            background-color: #007bff;
            color: white;
        }

        #addTextToStripBtn {
            background-color: #ffc107;
            color: #333;
        }
        
        #addImageToStripBtn, #addCustomStickerBtn {
            background-color: #28a745;
            color: white;
        }

        #exportFinalImageBtn, #saveDesignBtn, #shareDesignBtn {
            background-color: #6c757d;
            color: white;
        }

        /* Webcam Feed */
        #webcam-container {
            margin-top: 10px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f8f9fa;
        }

        #webcam-feed {
            width: 100%;
            max-width: 280px;
            height: auto;
            border-radius: 4px;
            transform: scaleX(-1); /* L·∫≠t ngang ƒë·ªÉ m√¥ ph·ªèng g∆∞∆°ng */
        }
        
        /* Layer Controls */
        #layer-controls {
            display: none; /* M·∫∑c ƒë·ªãnh ·∫©n, ch·ªâ hi·ªán khi c√≥ selectedObject */
            margin-top: 10px;
            padding: 10px;
            border: 2px dashed #007bff;
            border-radius: 4px;
            text-align: center;
        }

        #layer-controls button {
            background-color: #17a2b8;
            color: white;
            margin: 3px;
            padding: 5px 8px;
            font-size: 0.8em;
        }

        /* Sticker Library */
        #sticker-library {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .predefined-sticker {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s;
            text-align: center;
            font-size: 1.5em;
        }

        .predefined-sticker:hover {
            transform: scale(1.05);
            border-color: #007bff;
        }

    </style>
</head>
<body>
    <header>
        <h1 id="mainTitle">T·∫°o Strip Photo Booth C√° Nh√¢n</h1>
        <nav>
            <button onclick="showDesign(true)">‚ûï Thi·∫øt K·∫ø M·ªõi</button>
            <button onclick="showLibrary()">üìö Th∆∞ Vi·ªán</button>
        </nav>
    </header>

    <div class="main-container">

        <div id="library-view">
            <div class="library-actions">
                <button onclick="showDesign(true)">‚ûï B·∫Øt ƒë·∫ßu Thi·∫øt k·∫ø M·ªõi</button>
            </div>
            <h2>C√°c Thi·∫øt K·∫ø ƒê√£ L∆∞u</h2>
            <div id="design-list" class="design-list">
                </div>
        </div>

        <div id="design-view">
            
            <div id="controls-panel" class="controls-panel">
                
                <div class="control-group">
                    <h3>üìè C·∫•u H√¨nh Strip</h3>
                    <label for="stripWidth">Chi·ªÅu R·ªông (px):</label>
                    <input type="number" id="stripWidth" value="300" min="100" max="600">
                    <label for="stripHeight">Chi·ªÅu Cao (px):</label>
                    <input type="number" id="stripHeight" value="900" min="300" max="1200">
                    
                    <label for="frameColor">M√†u Khung:</label>
                    <input type="color" id="frameColor" value="#000000">
                    <label for="frameThickness">ƒê·ªô D√†y Khung (px):</label>
                    <input type="range" id="frameThickness" value="10" min="0" max="30">
                    
                    <label for="photoSizeScale">K√≠ch th∆∞·ªõc ·∫¢nh (%):</label>
                    <input type="range" id="photoSizeScale" value="90" min="50" max="100">
                </div>
                
                <div class="control-group">
                    <h3>üì∑ Ch·ª•p ·∫¢nh</h3>
                    <div id="webcam-container">
                        <video id="webcam-feed" autoplay></video>
                    </div>
                    <button id="capturePhotoBtn">Ch·ª•p ·∫¢nh (1/4)</button>
                    <p id="captureStatus"></p>
                </div>

                <div class="control-group">
                    <h3>üé® ƒê·ªëi T∆∞·ª£ng T√πy Ch·ªânh</h3>
                    
                    <label for="textInput">N·ªôi dung Text:</label>
                    <input type="text" id="textInput" placeholder="Nh·∫≠p ch·ªØ v√†o ƒë√¢y">
                    <label for="fontSize">C·ª° ch·ªØ (px):</label>
                    <input type="range" id="fontSize" value="30" min="10" max="100">
                    <button id="addTextToStripBtn">Th√™m Text</button>
                    
                    <h4>Sticker Nhanh</h4>
                    <div id="sticker-library">
                        <span class="predefined-sticker" data-sticker-url="https://via.placeholder.com/50/FF0000/FFFFFF?text=%E2%9D%A4%EF%B8%8F">‚ù§Ô∏è</span>
                        <span class="predefined-sticker" data-sticker-url="https://via.placeholder.com/50/00FF00/FFFFFF?text=%E2%9C%85">‚úÖ</span>
                        <span class="predefined-sticker" data-sticker-url="https://via.placeholder.com/50/0000FF/FFFFFF?text=%F0%9F%99%82">üôÇ</span>
                    </div>

                    <h4>T·∫£i L√™n ·∫¢nh/Sticker (PNG/JPG)</h4>
                    <input type="file" id="imageUpload" accept="image/*">
                    <button id="addImageToStripBtn">Th√™m ·∫¢nh</button>
                </div>
                
                <div id="layer-controls" class="control-group">
                    <h3>‚¨ÜÔ∏è Qu·∫£n L√Ω L·ªõp</h3>
                    <p>ƒê·ªëi t∆∞·ª£ng ƒëang ch·ªçn: <span id="selectedObjectType"></span></p>
                    <button id="bringToFrontBtn">L√™n Tr√™n C√πng</button>
                    <button id="bringForwardBtn">L√™n M·ªôt L·ªõp</button>
                    <button id="sendBackwardBtn">Xu·ªëng M·ªôt L·ªõp</button>
                    <button id="sendToBackBtn">Xu·ªëng D∆∞·ªõi C√πng</button>
                </div>

                <div class="button-group">
                    <button id="saveDesignBtn">üíæ L∆∞u Thi·∫øt K·∫ø</button>
                    <button id="shareDesignBtn">üîó T·∫°o Link Chia S·∫ª</button>
                    <button id="exportFinalImageBtn">üì∏ T·∫£i ·∫¢nh Strip Cu·ªëi C√πng (PNG)</button>
                </div>
            </div>

            <div id="canvas-container" class="canvas-container">
                <canvas id="photoStripCanvas"></canvas>
            </div>
            
        </div>
    </div>

    <script>
        // Khai b√°o c√°c bi·∫øn DOM
        const canvas = document.getElementById('photoStripCanvas');
        const ctx = canvas.getContext('2d');
        const webcamFeed = document.getElementById('webcam-feed');
        const capturePhotoBtn = document.getElementById('capturePhotoBtn');
        const captureStatus = document.getElementById('captureStatus');
        const addTextToStripBtn = document.getElementById('addTextToStripBtn');
        const exportFinalImageBtn = document.getElementById('exportFinalImageBtn');
        const designView = document.getElementById('design-view');
        const libraryView = document.getElementById('library-view');
        const mainTitle = document.getElementById('mainTitle');
        const designList = document.getElementById('design-list');
        const saveDesignBtn = document.getElementById('saveDesignBtn');
        const controlsPanel = document.getElementById('controls-panel');
        const webcamContainer = document.getElementById('webcam-container');
        const layerControls = document.getElementById('layer-controls');
        const bringForwardBtn = document.getElementById('bringForwardBtn');
        const sendBackwardBtn = document.getElementById('sendBackwardBtn');
        const bringToFrontBtn = document.getElementById('bringToFrontBtn');
        const sendToBackBtn = document.getElementById('sendToBackBtn');
        const selectedObjectTypeSpan = document.getElementById('selectedObjectType');
        const stickerLibrary = document.getElementById('sticker-library');
        const addImageToStripBtn = document.getElementById('addImageToStripBtn');
        const imageUpload = document.getElementById('imageUpload');
        const shareDesignBtn = document.getElementById('shareDesignBtn');
        
        // Khai b√°o Input Controls
        const frameColorInput = document.getElementById('frameColor');
        const frameThicknessInput = document.getElementById('frameThickness');
        const photoSizeScaleInput = document.getElementById('photoSizeScale');
        const stripWidthInput = document.getElementById('stripWidth');
        const stripHeightInput = document.getElementById('stripHeight');
        const textInput = document.getElementById('textInput');
        const fontSizeInput = document.getElementById('fontSize');

        // Bi·∫øn tr·∫°ng th√°i
        let capturedPhotos = [];
        let currentPhotoIndex = 0;
        let canvasObjects = []; // M·∫£ng ch·ª©a c√°c ƒë·ªëi t∆∞·ª£ng (·∫£nh, sticker, text)
        let selectedObject = null;
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let startX, startY;
        let lastAngle = 0;
        let currentDesignId = null; // ID cho localStorage

        // =======================================================
        // PH·∫¶N 1: LOGIC WEBCAM V√Ä CH·ª§P ·∫¢NH
        // =======================================================

        async function startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                webcamFeed.srcObject = stream;
            } catch (err) {
                console.error("L·ªói truy c·∫≠p webcam:", err);
                alert("Kh√¥ng th·ªÉ truy c·∫≠p webcam. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p.");
            }
        }

        function updateCaptureButtonText() {
            if (currentPhotoIndex < 4) {
                capturePhotoBtn.textContent = `Ch·ª•p ·∫¢nh (${currentPhotoIndex + 1}/4)`;
                captureStatus.textContent = `C√≤n ${4 - currentPhotoIndex} ·∫£nh c·∫ßn ch·ª•p.`;
            } else {
                capturePhotoBtn.textContent = 'Ho√†n th√†nh';
                captureStatus.textContent = 'B·∫°n ƒë√£ ch·ª•p ƒë·ªß 4 ·∫£nh! C√≥ th·ªÉ xu·∫•t file.';
            }
            if (currentPhotoIndex === 0) {
                 capturePhotoBtn.textContent = 'B·∫Øt ƒë·∫ßu Ch·ª•p (1/4)';
            }
        }

        function capturePhoto() {
            if (currentPhotoIndex >= 4) return;

            const tempCanvas = document.createElement('canvas');
            const videoRatio = webcamFeed.videoWidth / webcamFeed.videoHeight;
            const desiredHeight = 600; // Chi·ªÅu cao ·∫£nh ch·ª•p ti√™u chu·∫©n
            const desiredWidth = desiredHeight * videoRatio;
            
            tempCanvas.width = desiredWidth;
            tempCanvas.height = desiredHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // V·∫Ω video frame l√™n canvas (v√† l·∫≠t ngang)
            tempCtx.translate(desiredWidth, 0);
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(webcamFeed, 0, 0, desiredWidth, desiredHeight);

            const dataURL = tempCanvas.toDataURL('image/jpeg', 0.9);
            const capturedImage = new Image();
            capturedImage.onload = () => {
                capturedPhotos.push({
                    index: currentPhotoIndex,
                    image: capturedImage,
                    src: dataURL
                });
                currentPhotoIndex++;
                updateCaptureButtonText();
                drawFrame(); // V·∫Ω l·∫°i canvas
            };
            capturedImage.src = dataURL;
        }

        // =======================================================
        // PH·∫¶N 2: LOGIC V·∫º CANVAS
        // =======================================================

        function drawFrame() {
            // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas theo input
            const stripWidth = parseInt(stripWidthInput.value);
            const stripHeight = parseInt(stripHeightInput.value);
            canvas.width = stripWidth;
            canvas.height = stripHeight;

            // X√≥a canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // C√†i ƒë·∫∑t chung
            const frameColor = frameColorInput.value;
            const frameThickness = parseInt(frameThicknessInput.value);
            const photoSizeScale = parseInt(photoSizeScaleInput.value) / 100;
            const photoCount = 4;
            const photoAreaHeight = canvas.height - frameThickness * 2;
            const photoHeightTotal = photoAreaHeight / photoCount;
            const photoWidthTotal = canvas.width - frameThickness * 2;

            // V·∫Ω n·ªÅn
            ctx.fillStyle = frameColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // T√≠nh to√°n k√≠ch th∆∞·ªõc ·∫£nh
            const photoWidth = photoWidthTotal * photoSizeScale;
            const photoHeight = photoHeightTotal * photoSizeScale;
            const horizontalOffset = (photoWidthTotal - photoWidth) / 2;
            const verticalSpacing = (photoHeightTotal - photoHeight) / (photoCount + 1);
            
            // V·∫Ω c√°c ·∫£nh ƒë√£ ch·ª•p
            for (let i = 0; i < photoCount; i++) {
                const photoY = frameThickness + (photoHeightTotal * i) + (photoHeightTotal - photoHeight) / 2;
                const photoX = frameThickness + horizontalOffset;
                
                // V·∫Ω khung n·ªôi b·ªô (m√†u n·ªÅn ·∫£nh)
                ctx.fillStyle = '#fefefe';
                ctx.fillRect(photoX, photoY, photoWidth, photoHeight);

                if (capturedPhotos[i] && capturedPhotos[i].image) {
                    // V·∫Ω ·∫£nh ƒë√£ ch·ª•p
                    ctx.drawImage(capturedPhotos[i].image, photoX, photoY, photoWidth, photoHeight);
                }

                // V·∫Ω ƒë∆∞·ªùng vi·ªÅn nh·ªè (t√πy ch·ªçn)
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(photoX, photoY, photoWidth, photoHeight);
            }

            // V·∫Ω c√°c ƒë·ªëi t∆∞·ª£ng th√™m v√†o (Sticker, Text) theo Layer
            canvasObjects.forEach(obj => {
                ctx.save();
                
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                
                // √Åp d·ª•ng ph√©p bi·∫øn ƒë·ªïi (xoay, d·ªãch chuy·ªÉn)
                ctx.translate(centerX, centerY);
                ctx.rotate(obj.angle);
                
                if (obj.type === 'image' || obj.type === 'sticker') {
                    if (obj.image) {
                        ctx.drawImage(obj.image, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
                    }
                } else if (obj.type === 'text') {
                    ctx.fillStyle = obj.color || '#000000';
                    ctx.font = `${obj.fontSize}px ${obj.fontFamily || 'Arial'}`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(obj.text, 0, 0); // V·∫Ω t·∫°i v·ªã tr√≠ (0, 0) sau khi translate
                }
                
                ctx.restore();
            });

            // V·∫Ω khung l·ª±a ch·ªçn v√† tay c·∫ßm n·∫øu c√≥ ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c ch·ªçn
            if (selectedObject) {
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                ctx.save();
                
                const centerX = selectedObject.x + selectedObject.width / 2;
                const centerY = selectedObject.y + selectedObject.height / 2;
                
                ctx.translate(centerX, centerY);
                ctx.rotate(selectedObject.angle);
                
                // 1. V·∫Ω khung bao
                ctx.strokeRect(-selectedObject.width / 2, -selectedObject.height / 2, selectedObject.width, selectedObject.height);
                ctx.setLineDash([]); // T·∫Øt n√©t ƒë·ª©t

                // 2. Tay c·∫ßm xoay (Rotation Handle - ƒê·ªè)
                const rotateHandleX = -selectedObject.width / 2;
                const rotateHandleY = -selectedObject.height / 2;
                
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(rotateHandleX, rotateHandleY, 6, 0, Math.PI * 2);
                ctx.fill();

                // 3. Tay c·∫ßm thay ƒë·ªïi k√≠ch th∆∞·ªõc (Resize Handle - Xanh Cyan)
                const resizeHandleX = selectedObject.width / 2;
                const resizeHandleY = selectedObject.height / 2;
                
                ctx.fillStyle = 'cyan';
                ctx.beginPath();
                ctx.arc(resizeHandleX, resizeHandleY, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // C·∫≠p nh·∫≠t th√¥ng tin layer control
        function updateLayerControls() {
            if (selectedObject) {
                layerControls.style.display = 'block';
                selectedObjectTypeSpan.textContent = selectedObject.type.toUpperCase();
                // ƒê·ªìng b·ªô c·ª° ch·ªØ
                if (selectedObject.type === 'text') {
                    fontSizeInput.value = selectedObject.fontSize;
                }
            } else {
                layerControls.style.display = 'none';
            }
        }
        
        // =======================================================
        // PH·∫¶N 3: LOGIC TH√äM ƒê·ªêI T∆Ø·ª¢NG V√Ä T∆Ø∆†NG T√ÅC
        // =======================================================

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            // ƒêi·ªÅu ch·ªânh t·ªça ƒë·ªô theo t·ª∑ l·ªá canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // Ki·ªÉm tra xem m·ªôt ƒëi·ªÉm c√≥ n·∫±m trong ƒë·ªëi t∆∞·ª£ng kh√¥ng
        function isPointInObject(x, y, obj) {
            // ƒê·∫£o ng∆∞·ª£c ph√©p xoay c·ªßa ƒëi·ªÉm chu·ªôt
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;
            const dx = x - centerX;
            const dy = y - centerY;

            const cos = Math.cos(-obj.angle);
            const sin = Math.sin(-obj.angle);

            const rotatedX = dx * cos - dy * sin;
            const rotatedY = dx * sin + dy * cos;

            // Ki·ªÉm tra trong bounding box ƒë√£ xoay
            return rotatedX >= -obj.width / 2 &&
                   rotatedX <= obj.width / 2 &&
                   rotatedY >= -obj.height / 2 &&
                   rotatedY <= obj.height / 2;
        }

        // Ki·ªÉm tra tay c·∫ßm xoay (Rotation Handle - g√≥c tr√™n tr√°i)
        function isPointInRotateHandle(x, y, obj) {
            if (!obj) return false;
            const handleSize = 12; // ƒê∆∞·ªùng k√≠nh handle
            
            // T√≠nh to√°n v·ªã tr√≠ tay c·∫ßm trong kh√¥ng gian canvas
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;
            
            const localX = -obj.width / 2;
            const localY = -obj.height / 2;
            
            const cos = Math.cos(obj.angle);
            const sin = Math.sin(obj.angle);

            const handleX = centerX + (localX * cos - localY * sin);
            const handleY = centerY + (localX * sin + localY * cos);

            return x >= handleX - handleSize / 2 &&
                   x <= handleX + handleSize / 2 &&
                   y >= handleY - handleSize / 2 &&
                   y <= handleY + handleSize / 2;
        }

        // Ki·ªÉm tra tay c·∫ßm thay ƒë·ªïi k√≠ch th∆∞·ªõc (Resize Handle - g√≥c d∆∞·ªõi ph·∫£i)
        function isPointInResizeHandle(x, y, obj) {
            if (!obj) return false;
            const handleSize = 12;
            
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;
            
            const localX = obj.width / 2;
            const localY = obj.height / 2;
            
            const cos = Math.cos(obj.angle);
            const sin = Math.sin(obj.angle);

            const handleX = centerX + (localX * cos - localY * sin);
            const handleY = centerY + (localX * sin + localY * cos);

            return x >= handleX - handleSize / 2 &&
                   x <= handleX + handleSize / 2 &&
                   y >= handleY - handleSize / 2 &&
                   y <= handleY + handleSize / 2;
        }

        // X·ª≠ l√Ω th√™m Text
        function handleTextAdd() {
            const text = textInput.value || 'Text M·∫´u';
            const fontSize = parseInt(fontSizeInput.value);
            
            const newText = {
                type: 'text',
                text: text,
                x: canvas.width / 2 - 50, // V·ªã tr√≠ kh·ªüi t·∫°o
                y: canvas.height / 2,
                width: 100, // Chi·ªÅu r·ªông ∆∞·ªõc t√≠nh (cho bounding box)
                height: fontSize, // Chi·ªÅu cao ∆∞·ªõc t√≠nh
                fontSize: fontSize,
                color: '#ff0000',
                fontFamily: 'Arial',
                angle: 0
            };
            canvasObjects.push(newText);
            selectedObject = newText;
            drawFrame();
            updateLayerControls();
        }

        // X·ª≠ l√Ω th√™m Image/Sticker
        function handleImageAdd(src, name, type) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                const ratio = img.width / img.height;
                let newWidth = 150; // K√≠ch th∆∞·ªõc kh·ªüi t·∫°o
                let newHeight = 150 / ratio;

                const newObject = {
                    type: type,
                    name: name,
                    image: img,
                    src: src, // Gi·ªØ l·∫°i src ƒë·ªÉ l∆∞u tr·ªØ
                    x: canvas.width / 2 - newWidth / 2,
                    y: canvas.height / 2 - newHeight / 2,
                    width: newWidth,
                    height: newHeight,
                    angle: 0
                };
                canvasObjects.push(newObject);
                selectedObject = newObject;
                drawFrame();
                updateLayerControls();
            };
            img.src = src;
        }
        
        // X·ª≠ l√Ω s·ª± ki·ªán chu·ªôt ph·∫£i (Context Menu)
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // NgƒÉn menu chu·ªôt ph·∫£i m·∫∑c ƒë·ªãnh
            const mousePos = getMousePos(e);

            // Ki·ªÉm tra xem chu·ªôt c√≥ ƒëang n·∫±m tr√™n ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c ch·ªçn kh√¥ng
            if (selectedObject && isPointInObject(mousePos.x, mousePos.y, selectedObject)) {
                if (confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ${selectedObject.type.toUpperCase()} n√†y kh√¥ng?`)) {
                    const index = canvasObjects.indexOf(selectedObject);
                    if (index > -1) {
                        canvasObjects.splice(index, 1);
                        selectedObject = null;
                        drawFrame();
                        updateLayerControls();
                    }
                }
            }
        });
        
        // Ti·∫øp t·ª•c ph·∫ßn JS b·ªã c·∫Øt ·ªü request tr∆∞·ªõc
        function handleMouseDown(e) {
            e.preventDefault();
            if (controlsPanel.style.display === 'none') return; // Kh√¥ng cho t∆∞∆°ng t√°c n·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô chia s·∫ª
            
            const mousePos = getMousePos(e);
            selectedObject = null;
            updateLayerControls();

            // Duy·ªát t·ª´ tr√™n xu·ªëng (t·ª©c l√† t·ª´ cu·ªëi m·∫£ng) ƒë·ªÉ ch·ªçn ƒë·ªëi t∆∞·ª£ng tr√™n c√πng
            for (let i = canvasObjects.length - 1; i >= 0; i--) {
                const obj = canvasObjects[i];

                if (isPointInRotateHandle(mousePos.x, mousePos.y, obj)) {
                    selectedObject = obj;
                    isRotating = true;
                    startX = mousePos.x;
                    startY = mousePos.y;
                    // T√≠nh g√≥c ban ƒë·∫ßu ƒë·ªÉ ƒëi·ªÅu ch·ªânh ƒë·ªô l·ªách
                    const dx = startX - (obj.x + obj.width / 2);
                    const dy = startY - (obj.y + obj.height / 2);
                    lastAngle = Math.atan2(dy, dx) - obj.angle;
                    drawFrame();
                    updateLayerControls();
                    return;
                }

                if (isPointInResizeHandle(mousePos.x, mousePos.y, obj) && (obj.type === 'image' || obj.type === 'sticker' || obj.type === 'text')) {
                    selectedObject = obj;
                    isResizing = true;
                    startX = mousePos.x - obj.width;
                    startY = mousePos.y - obj.height;
                    drawFrame();
                    updateLayerControls();
                    return;
                }

                if (isPointInObject(mousePos.x, mousePos.y, obj)) {
                    selectedObject = obj;
                    isDragging = true;
                    startX = mousePos.x - obj.x;
                    startY = mousePos.y - obj.y;
                    drawFrame();
                    updateLayerControls();
                    return;
                }
            }
            
            // N·∫øu kh√¥ng ch·ªçn ƒë∆∞·ª£c ƒë·ªëi t∆∞·ª£ng n√†o, b·ªè ch·ªçn
            if (!isDragging && !isResizing && !isRotating) {
                selectedObject = null;
                drawFrame();
                updateLayerControls();
            }
        }

        function handleMouseMove(e) {
            if (controlsPanel.style.display === 'none' || !selectedObject) return;
            
            const mousePos = getMousePos(e);

            if (isDragging) {
                selectedObject.x = mousePos.x - startX;
                selectedObject.y = mousePos.y - startY;
            } else if (isResizing) {
                // T√≠nh to√°n thay ƒë·ªïi k√≠ch th∆∞·ªõc d·ª±a tr√™n g√≥c
                const centerX = selectedObject.x + selectedObject.width / 2;
                const centerY = selectedObject.y + selectedObject.height / 2;

                const dx = mousePos.x - centerX;
                const dy = mousePos.y - centerY;

                const cos = Math.cos(-selectedObject.angle);
                const sin = Math.sin(-selectedObject.angle);

                const rotatedX = dx * cos - dy * sin;
                const rotatedY = dx * sin + dy * cos;
                
                let newWidth = rotatedX * 2;
                let newHeight = rotatedY * 2;
                
                if (selectedObject.type === 'image' || selectedObject.type === 'sticker') {
                    const aspectRatio = selectedObject.image.height / selectedObject.image.width;
                    newWidth = Math.max(20, newWidth);
                    newHeight = newWidth * aspectRatio;
                    selectedObject.width = newWidth;
                    selectedObject.height = newHeight;
                } else if (selectedObject.type === 'text') {
                    // Thay ƒë·ªïi c·ª° ch·ªØ
                    const newFontSize = Math.max(10, Math.min(100, newHeight));
                    selectedObject.fontSize = newFontSize;
                    selectedObject.height = newFontSize; // C·∫≠p nh·∫≠t chi·ªÅu cao bounding box
                }
                
            } else if (isRotating) {
                const centerX = selectedObject.x + selectedObject.width / 2;
                const centerY = selectedObject.y + selectedObject.height / 2;
                
                const dx = mousePos.x - centerX;
                const dy = mousePos.y - centerY;
                
                let newAngle = Math.atan2(dy, dx);
                selectedObject.angle = newAngle - lastAngle;
            }

            if (isDragging || isResizing || isRotating) {
                drawFrame();
            }
        }

        function handleMouseUp(e) {
            isDragging = false;
            isResizing = false;
            isRotating = false;
            drawFrame();
        }

        // =======================================================
        // PH·∫¶N 4: LOGIC QU·∫¢N L√ù L·ªöP (LAYER)
        // =======================================================
        function changeLayer(direction) {
            if (!selectedObject) return;
            
            const index = canvasObjects.indexOf(selectedObject);
            if (index === -1) return;

            let newIndex = index + direction;
            
            if (direction === Infinity) newIndex = canvasObjects.length - 1;
            else if (direction === -Infinity) newIndex = 0;

            // ƒê·∫£m b·∫£o index m·ªõi n·∫±m trong gi·ªõi h·∫°n
            newIndex = Math.min(Math.max(0, newIndex), canvasObjects.length - 1);

            if (newIndex !== index) {
                // Di chuy·ªÉn ƒë·ªëi t∆∞·ª£ng trong m·∫£ng
                canvasObjects.splice(index, 1); // X√≥a ƒë·ªëi t∆∞·ª£ng kh·ªèi v·ªã tr√≠ c≈©
                canvasObjects.splice(newIndex, 0, selectedObject); // Ch√®n v√†o v·ªã tr√≠ m·ªõi
                drawFrame();
            }
        }

        // G·∫Øn s·ª± ki·ªán cho Layer Controls (ƒë·∫∑t ·ªü setupEventListeners)

        // =======================================================
        // PH·∫¶N 5: LOGIC CHUY·ªÇN ƒê·ªîI CH·∫æ ƒê·ªò V√Ä L∆ØU TR·ªÆ
        // =======================================================

        function showDesign(isNew = false) {
            designView.style.display = 'flex';
            controlsPanel.style.display = 'block';
            libraryView.style.display = 'none';
            mainTitle.textContent = 'T·∫°o Strip Photo Booth C√° Nh√¢n';
            
            // Kh·ªüi t·∫°o n·∫øu l√† m·∫´u m·ªõi
            if (isNew) {
                capturedPhotos = [];
                currentPhotoIndex = 0;
                canvasObjects = [];
                selectedObject = null;
                updateCaptureButtonText();
                currentDesignId = null;
            }
            startWebcam();
            drawFrame();
            updateLayerControls();
            
            // Kh√¥i ph·ª•c layout m·∫∑c ƒë·ªãnh
            document.querySelector('header').style.display = 'block';
            document.body.style.backgroundColor = '#f0f2f5';
            document.querySelector('.main-container').style.padding = '20px';
            webcamContainer.style.display = 'block'; 
        }

        function showLibrary() {
            designView.style.display = 'none';
            libraryView.style.display = 'block';
            mainTitle.textContent = 'üìö Th∆∞ Vi·ªán M·∫´u Thi·∫øt K·∫ø C·ªßa T√¥i';
            loadDesignList();
            
            // D·ª´ng webcam
            if (webcamFeed.srcObject) {
                webcamFeed.srcObject.getTracks().forEach(track => track.stop());
            }
        }

        // Ch·∫ø ƒë·ªô ch·ªâ xem (View Mode) cho link chia s·∫ª
        function showShareView() {
            // ·∫®n t·∫•t c·∫£ c√°c control v√† view kh√¥ng c·∫ßn thi·∫øt
            document.querySelector('.main-container').style.padding = '0';
            document.querySelector('header').style.display = 'none';
            controlsPanel.style.display = 'none';
            designView.style.display = 'flex';
            libraryView.style.display = 'none';
            webcamContainer.style.display = 'none'; 

            // C·∫≠p nh·∫≠t l·∫°i body v√† container ƒë·ªÉ ch·ªâ hi·ªÉn th·ªã canvas
            document.body.style.backgroundColor = '#000';
            document.querySelector('.main-container').style.width = '100vw';
            document.querySelector('.main-container').style.height = '100vh';
            document.querySelector('.main-container').style.margin = '0';
            designView.style.flexDirection = 'column';
            canvasContainer.style.flexGrow = 1;

            // D·ª´ng webcam
            if (webcamFeed.srcObject) {
                webcamFeed.srcObject.getTracks().forEach(track => track.stop());
            }
            selectedObject = null;
            drawFrame();
        }

        function getDesignData() {
            return {
                id: currentDesignId || Date.now(),
                name: `Thi·∫øt k·∫ø ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`,
                timestamp: Date.now(),
                config: {
                    frameColor: frameColorInput.value,
                    frameThickness: parseInt(frameThicknessInput.value),
                    photoSizeScale: parseFloat(photoSizeScaleInput.value),
                    stripWidth: parseInt(stripWidthInput.value),
                    stripHeight: parseInt(stripHeightInput.value),
                    capturedPhotos: capturedPhotos.map(p => p.src), // Ch·ªâ l∆∞u data URL
                    canvasObjects: canvasObjects.map(obj => {
                        const clone = { ...obj };
                        delete clone.image; // X√≥a tham chi·∫øu t·ªõi ƒë·ªëi t∆∞·ª£ng Image
                        return clone;
                    })
                }
            };
        }
        
        function saveDesignToLocalStorage() {
            const designData = getDesignData();
            let designs = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
            
            const existingIndex = designs.findIndex(d => d.id === designData.id);
            if (existingIndex > -1) {
                designs[existingIndex] = designData;
            } else {
                designs.push(designData);
            }
            
            localStorage.setItem('photoBoothDesigns', JSON.stringify(designs));
            alert("Thi·∫øt k·∫ø ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o Th∆∞ vi·ªán!");
        }

        async function loadDesign(designConfig, designId) {
            currentDesignId = designId;
            frameColorInput.value = designConfig.frameColor;
            frameThicknessInput.value = designConfig.frameThickness;
            photoSizeScaleInput.value = designConfig.photoSizeScale;
            stripWidthInput.value = designConfig.stripWidth;
            stripHeightInput.value = designConfig.stripHeight;
            
            // T·∫£i l·∫°i ·∫£nh ch·ª•p
            capturedPhotos = [];
            for (let i = 0; i < designConfig.capturedPhotos.length; i++) {
                const src = designConfig.capturedPhotos[i];
                const img = new Image();
                await new Promise(resolve => {
                    img.onload = resolve;
                    img.src = src;
                });
                capturedPhotos.push({ index: i, image: img, src: src });
            }
            currentPhotoIndex = capturedPhotos.length;
            updateCaptureButtonText();

            // T·∫£i l·∫°i c√°c ƒë·ªëi t∆∞·ª£ng canvas
            canvasObjects = [];
            for (const objData of designConfig.canvasObjects) {
                if (objData.type === 'image' || objData.type === 'sticker') {
                    const img = new Image();
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.crossOrigin = "Anonymous";
                        img.src = objData.src;
                    });
                    canvasObjects.push({ ...objData, image: img });
                } else if (objData.type === 'text') {
                    canvasObjects.push(objData);
                }
            }
        }

        async function loadDesignFromURL(encodedDesign) {
            try {
                // Gi·∫£i m√£ chu·ªói Base64
                const jsonString = atob(encodedDesign);
                const designConfig = JSON.parse(jsonString);
                
                // T·∫£i thi·∫øt k·∫ø v√† hi·ªÉn th·ªã ·ªü ch·∫ø ƒë·ªô chia s·∫ª
                await loadDesign(designConfig, null);
                showShareView();
                document.title = "Photo Strip Design Shared";
            } catch (e) {
                console.error("Error loading design from URL:", e);
                alert("Thi·∫øt k·∫ø kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ b·ªã l·ªói. ƒêang chuy·ªÉn v·ªÅ trang thi·∫øt k·∫ø.");
                window.location.href = window.location.origin + window.location.pathname; // Quay v·ªÅ trang ch√≠nh
            }
        }

        function loadDesignList() {
            const designs = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
            designList.innerHTML = ''; // Clear old list
            
            if (designs.length === 0) {
                designList.innerHTML = '<p>Ch∆∞a c√≥ thi·∫øt k·∫ø n√†o ƒë∆∞·ª£c l∆∞u. H√£y t·∫°o m·ªôt c√°i m·ªõi!</p>';
                return;
            }

            designs.forEach(design => {
                const card = document.createElement('div');
                card.className = 'design-card';
                card.innerHTML = `
                    <h3>${design.name}</h3>
                    <p>${design.config.stripWidth}x${design.config.stripHeight} Strip</p>
                    <p>L∆∞u l√∫c: ${new Date(design.timestamp).toLocaleString()}</p>
                    <div class="action-group">
                        <button class="load-btn">T·∫£i Thi·∫øt K·∫ø</button>
                        <button class="delete-btn">X√≥a</button>
                    </div>
                `;
                card.querySelector('.load-btn').onclick = () => {
                    loadDesign(design.config, design.id).then(() => showDesign());
                };
                card.querySelector('.delete-btn').onclick = () => {
                    if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a thi·∫øt k·∫ø n√†y kh√¥ng?")) {
                        let currentDesigns = JSON.parse(localStorage.getItem('photoBoothDesigns') || '[]');
                        currentDesigns = currentDesigns.filter(d => d.id !== design.id);
                        localStorage.setItem('photoBoothDesigns', JSON.stringify(currentDesigns));
                        loadDesignList();
                    }
                };
                designList.appendChild(card);
            });
        }
        
        function createShareLink() {
            const designData = getDesignData();
            
            // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu config th√†nh JSON string
            const jsonString = JSON.stringify(designData.config);
            
            // M√£ h√≥a th√†nh Base64 (ƒë·ªÉ tr√°nh l·ªói k√Ω t·ª± trong URL)
            const encodedDesign = btoa(jsonString);
            
            // T·∫°o URL
            const shareURL = window.location.origin + window.location.pathname + `?design=${encodedDesign}`;

            // Hi·ªÉn th·ªã link cho ng∆∞·ªùi d√πng
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareURL).then(() => {
                    alert("ƒê√£ sao ch√©p link chia s·∫ª v√†o clipboard!");
                }).catch(err => {
                    prompt("Sao ch√©p link chia s·∫ª sau:", shareURL);
                });
            } else {
                 prompt("Sao ch√©p link chia s·∫ª sau:", shareURL);
            }
        }


        function exportFinalImage() {
            // T·∫°m th·ªùi ·∫©n vi·ªÅn l·ª±a ch·ªçn
            const tempSelectedObject = selectedObject;
            selectedObject = null;
            drawFrame();

            const dataURL = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = `photo-strip-${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            // Kh√¥i ph·ª•c tr·∫°ng th√°i
            selectedObject = tempSelectedObject;
            drawFrame();
        }

        // =======================================================
        // PH·∫¶N 6: G·∫ÆN S·ª∞ KI·ªÜN V√Ä KH·ªûI T·∫†O CU·ªêI C√ôNG
        // =======================================================

        function setupEventListeners() {
            // S·ª± ki·ªán t∆∞∆°ng t√°c Canvas
            canvas.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);

            // S·ª± ki·ªán thay ƒë·ªïi Input
            frameColorInput.addEventListener('input', drawFrame);
            frameThicknessInput.addEventListener('input', drawFrame);
            photoSizeScaleInput.addEventListener('input', drawFrame);
            stripWidthInput.addEventListener('input', drawFrame);
            stripHeightInput.addEventListener('input', drawFrame);
            fontSizeInput.addEventListener('input', drawFrame);

            // S·ª± ki·ªán N√∫t
            capturePhotoBtn.addEventListener('click', capturePhoto);
            addTextToStripBtn.addEventListener('click', handleTextAdd);
            exportFinalImageBtn.addEventListener('click', exportFinalImage);
            saveDesignBtn.addEventListener('click', saveDesignToLocalStorage);
            shareDesignBtn.addEventListener('click', createShareLink);
            
            // Layer Controls
            bringForwardBtn.addEventListener('click', () => changeLayer(1));
            sendBackwardBtn.addEventListener('click', () => changeLayer(-1));
            bringToFrontBtn.addEventListener('click', () => changeLayer(Infinity));
            sendToBackBtn.addEventListener('click', () => changeLayer(-Infinity));

            // T·∫£i l√™n ·∫¢nh/Sticker t√πy ch·ªânh
            addImageToStripBtn.addEventListener('click', () => {
                if (imageUpload.files.length > 0) {
                    const file = imageUpload.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => handleImageAdd(e.target.result, file.name, 'image');
                    reader.readAsDataURL(file);
                } else {
                    alert("Vui l√≤ng ch·ªçn m·ªôt t·∫≠p tin ·∫£nh ƒë·ªÉ t·∫£i l√™n.");
                }
            });
            
            // Th√™m s·ª± ki·ªán cho Sticker Library (Sticker m·∫∑c ƒë·ªãnh)
            stickerLibrary.querySelectorAll('.predefined-sticker').forEach(btn => {
                btn.addEventListener('click', () => {
                    const stickerURL = btn.getAttribute('data-sticker-url');
                    // S·ª≠ d·ª•ng stickerURL (data URL c·ªßa placeholder image)
                    handleImageAdd(stickerURL, btn.textContent, 'sticker');
                });
            });
        }

        // Kh·ªüi t·∫°o khi trang t·∫£i xong
        window.onload = function() {
            setupEventListeners();
            
            const params = new URLSearchParams(window.location.search);
            const designParam = params.get('design');

            if (designParam) {
                // Ch·∫ø ƒë·ªô chia s·∫ª: T·∫£i thi·∫øt k·∫ø t·ª´ URL v√† ch·ªâ hi·ªÉn th·ªã canvas
                loadDesignFromURL(designParam);
                return;
            } else {
                // Ch·∫ø ƒë·ªô thi·∫øt k·∫ø/th∆∞ vi·ªán th√¥ng th∆∞·ªùng
                const designs = localStorage.getItem('photoBoothDesigns');
                if (designs && JSON.parse(designs).length > 0) {
                    showLibrary();
                } else {
                    showDesign(true); // T·∫°o thi·∫øt k·∫ø m·ªõi n·∫øu ch∆∞a c√≥ g√¨
                }
            }
        };
    </script>
</body>
</html>